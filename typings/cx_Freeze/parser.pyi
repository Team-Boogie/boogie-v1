"""
This type stub file was generated by pyright.
"""

from abc import ABC
from pathlib import Path
from cx_Freeze._compat import IS_MINGW, IS_WINDOWS

"""Implements `Parser` interface to create an abstraction to parse binary
files.
"""
if IS_WINDOWS or IS_MINGW:
    ...
LIEF_DISABLED = ...
LDD_DISABLED = ...
PE_EXT = ...
MAGIC_ELF = ...
NON_ELF_EXT = ...
class Parser(ABC):
    """`Parser` interface."""
    def __init__(self, path: list[str], bin_path_includes: list[str], silent: int = ...) -> None:
        ...
    
    @property
    def search_path(self) -> list[Path]:
        """The default search path."""
        ...
    
    def find_library(self, name: str, search_path: list[str | Path] | None = ...) -> Path | None:
        ...
    
    def get_dependent_files(self, filename: str | Path) -> set[Path]:
        """Return the file's dependencies using platform-specific tools."""
        ...
    


class PEParser(Parser):
    """`PEParser` is based on the `lief` package. If it is disabled,
    use the old friend `cx_Freeze.util` extension module.
    """
    def __init__(self, path: list[str], bin_path_includes: list[str], silent: int = ...) -> None:
        ...
    
    @staticmethod
    def is_pe(filename: str | Path) -> bool:
        """Determines whether the file is a PE file."""
        ...
    
    _is_binary = ...
    if LIEF_DISABLED:
        _get_dependent_files = ...
    else:
        _get_dependent_files = ...
    def read_manifest(self, filename: str | Path) -> str:
        """:return: the XML schema of the manifest included in the executable
        :rtype: str

        """
        ...
    
    def write_manifest(self, filename: str | Path, manifest: str) -> None:
        """:return: write the XML schema of the manifest into the executable
        :rtype: str

        """
        ...
    


class ELFParser(Parser):
    """`ELFParser` is based on the logic around invoking `patchelf` and
    `ldd`.
    """
    def __init__(self, path: list[str], bin_path_includes: list[str], silent: int = ...) -> None:
        ...
    
    @staticmethod
    def is_elf(filename: str | Path) -> bool:
        """Check if the executable is an ELF."""
        ...
    
    _is_binary = ...
    if LDD_DISABLED:
        _get_dependent_files = ...
    else:
        _get_dependent_files = ...
    def get_needed(self, filename: Path) -> list[str]:
        """Gets the DT_NEEDED entry of the dynamic table."""
        ...
    
    def get_resolved_rpath(self, filename: str | Path) -> list[Path] | None:
        """Gets the resolved rpath of the executable."""
        ...
    
    def get_rpath(self, filename: str | Path) -> str:
        """Gets the rpath of the executable."""
        ...
    
    def replace_needed(self, filename: str | Path, so_name: str, new_so_name: str) -> None:
        """Replace DT_NEEDED entry in the dynamic table."""
        ...
    
    def set_rpath(self, filename: str | Path, rpath: str) -> None:
        """Sets the rpath of the executable."""
        ...
    
    def set_soname(self, filename: str | Path, new_so_name: str) -> None:
        """Sets DT_SONAME entry in the dynamic table."""
        ...
    
    def run_patchelf(self, args: list[str]) -> str:
        ...
    


