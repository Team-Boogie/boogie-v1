"""
This type stub file was generated by pyright.
"""

import abc
import enum
import io
import typing
from collections.abc import Iterable, Mapping
from ._helper import wrap_request_errors
from ..cookies import YoutubeDLCookieJar
from ..utils import classproperty
from ..utils.networking import HTTPHeaderDict

DEFAULT_TIMEOUT = ...
def register_preference(*handlers: type[RequestHandler]): # -> (preference: Preference) -> _Wrapped[(RequestHandler, Request), int, (handler: Unknown, *args: Unknown, **kwargs: Unknown), int]:
    ...

class RequestDirector:
    """RequestDirector class

    Helper class that, when given a request, forward it to a RequestHandler that supports it.

    Preference functions in the form of func(handler, request) -> int
    can be registered into the `preferences` set. These are used to sort handlers
    in order of preference.

    @param logger: Logger instance.
    @param verbose: Print debug request information to stdout.
    """
    def __init__(self, logger, verbose=...) -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def add_handler(self, handler: RequestHandler): # -> None:
        """Add a handler. If a handler of the same RH_KEY exists, it will overwrite it"""
        ...
    
    def send(self, request: Request) -> Response:
        """
        Passes a request onto a suitable RequestHandler
        """
        ...
    


_REQUEST_HANDLERS = ...
def register_rh(handler): # -> type[RequestHandler]:
    """Register a RequestHandler class"""
    ...

class Features(enum.Enum):
    ALL_PROXY = ...
    NO_PROXY = ...


class RequestHandler(abc.ABC):
    """Request Handler class

    Request handlers are class that, given a Request,
    process the request from start to finish and return a Response.

    Concrete subclasses need to redefine the _send(request) method,
    which handles the underlying request logic and returns a Response.

    RH_NAME class variable may contain a display name for the RequestHandler.
    By default, this is generated from the class name.

    The concrete request handler MUST have "RH" as the suffix in the class name.

    All exceptions raised by a RequestHandler should be an instance of RequestError.
    Any other exception raised will be treated as a handler issue.

    If a Request is not supported by the handler, an UnsupportedRequest
    should be raised with a reason.

    By default, some checks are done on the request in _validate() based on the following class variables:
    - `_SUPPORTED_URL_SCHEMES`: a tuple of supported url schemes.
        Any Request with an url scheme not in this list will raise an UnsupportedRequest.

    - `_SUPPORTED_PROXY_SCHEMES`: a tuple of support proxy url schemes. Any Request that contains
        a proxy url with an url scheme not in this list will raise an UnsupportedRequest.

    - `_SUPPORTED_FEATURES`: a tuple of supported features, as defined in Features enum.

    The above may be set to None to disable the checks.

    Parameters:
    @param logger: logger instance
    @param headers: HTTP Headers to include when sending requests.
    @param cookiejar: Cookiejar to use for requests.
    @param timeout: Socket timeout to use when sending requests.
    @param proxies: Proxies to use for sending requests.
    @param source_address: Client-side IP address to bind to for requests.
    @param verbose: Print debug request and traffic information to stdout.
    @param prefer_system_certs: Whether to prefer system certificates over other means (e.g. certifi).
    @param client_cert: SSL client certificate configuration.
            dict with {client_certificate, client_certificate_key, client_certificate_password}
    @param verify: Verify SSL certificates
    @param legacy_ssl_support: Enable legacy SSL options such as legacy server connect and older cipher support.

    Some configuration options may be available for individual Requests too. In this case,
    either the Request configuration option takes precedence or they are merged.

    Requests may have additional optional parameters defined as extensions.
     RequestHandler subclasses may choose to support custom extensions.

    If an extension is supported, subclasses should extend _check_extensions(extensions)
    to pop and validate the extension.
    - Extensions left in `extensions` are treated as unsupported and UnsupportedRequest will be raised.

    The following extensions are defined for RequestHandler:
    - `cookiejar`: Cookiejar to use for this request.
    - `timeout`: socket timeout to use for this request.
    - `legacy_ssl`: Enable legacy SSL options for this request. See legacy_ssl_support.
    To enable these, add extensions.pop('<extension>', None) to _check_extensions

    Apart from the url protocol, proxies dict may contain the following keys:
    - `all`: proxy to use for all protocols. Used as a fallback if no proxy is set for a specific protocol.
    - `no`: comma seperated list of hostnames (optionally with port) to not use a proxy for.
    Note: a RequestHandler may not support these, as defined in `_SUPPORTED_FEATURES`.

    """
    _SUPPORTED_URL_SCHEMES = ...
    _SUPPORTED_PROXY_SCHEMES = ...
    _SUPPORTED_FEATURES = ...
    def __init__(self, *, logger, headers: HTTPHeaderDict = ..., cookiejar: YoutubeDLCookieJar = ..., timeout: float | int | None = ..., proxies: dict | None = ..., source_address: str | None = ..., verbose: bool = ..., prefer_system_certs: bool = ..., client_cert: dict[str, str | None] | None = ..., verify: bool = ..., legacy_ssl_support: bool = ..., **_) -> None:
        ...
    
    @wrap_request_errors
    def validate(self, request: Request): # -> None:
        ...
    
    @wrap_request_errors
    def send(self, request: Request) -> Response:
        ...
    
    def close(self): # -> None:
        ...
    
    @classproperty
    def RH_NAME(cls): # -> str:
        ...
    
    @classproperty
    def RH_KEY(cls): # -> str:
        ...
    
    def __enter__(self): # -> Self@RequestHandler:
        ...
    
    def __exit__(self, *args): # -> None:
        ...
    


class Request:
    """
    Represents a request to be made.
    Partially backwards-compatible with urllib.request.Request.

    @param url: url to send. Will be sanitized.
    @param data: payload data to send. Must be bytes, iterable of bytes, a file-like object or None
    @param headers: headers to send.
    @param proxies: proxy dict mapping of proto:proxy to use for the request and any redirects.
    @param query: URL query parameters to update the url with.
    @param method: HTTP method to use. If no method specified, will use POST if payload data is present else GET
    @param extensions: Dictionary of Request extensions to add, as supported by handlers.
    """
    def __init__(self, url: str, data: RequestData = ..., headers: typing.Mapping | None = ..., proxies: dict | None = ..., query: dict | None = ..., method: str | None = ..., extensions: dict | None = ...) -> None:
        ...
    
    @property
    def url(self):
        ...
    
    @url.setter
    def url(self, url): # -> None:
        ...
    
    @property
    def method(self): # -> str:
        ...
    
    @method.setter
    def method(self, method): # -> None:
        ...
    
    @property
    def data(self): # -> RequestData | bytearray | memoryview | IOBase:
        ...
    
    @data.setter
    def data(self, data: RequestData): # -> None:
        ...
    
    @property
    def headers(self) -> HTTPHeaderDict:
        ...
    
    @headers.setter
    def headers(self, new_headers: Mapping): # -> None:
        """Replaces headers of the request. If not a HTTPHeaderDict, it will be converted to one."""
        ...
    
    def update(self, url=..., data=..., headers=..., query=..., extensions=...): # -> None:
        ...
    
    def copy(self): # -> Request:
        ...
    


HEADRequest = ...
PUTRequest = ...
class Response(io.IOBase):
    """
    Base class for HTTP response adapters.

    By default, it provides a basic wrapper for a file-like response object.

    Interface partially backwards-compatible with addinfourl and http.client.HTTPResponse.

    @param fp: Original, file-like, response.
    @param url: URL that this is a response of.
    @param headers: response headers.
    @param status: Response HTTP status code. Default is 200 OK.
    @param reason: HTTP status reason. Will use built-in reasons based on status code if not provided.
    @param extensions: Dictionary of handler-specific response extensions.
    """
    def __init__(self, fp: io.IOBase, url: str, headers: Mapping[str, str], status: int = ..., reason: str | None = ..., extensions: dict | None = ...) -> None:
        ...
    
    def readable(self): # -> bool:
        ...
    
    def read(self, amt: int | None = ...) -> bytes:
        ...
    
    def close(self): # -> None:
        ...
    
    def get_header(self, name, default=...): # -> _HeaderType | LiteralString | None:
        """Get header for name.
        If there are multiple matching headers, return all seperated by comma."""
        ...
    
    @property
    def code(self): # -> int:
        ...
    
    def getcode(self): # -> int:
        ...
    
    def geturl(self): # -> str:
        ...
    
    def info(self): # -> Message:
        ...
    
    def getheader(self, name, default=...): # -> _HeaderType | LiteralString | None:
        ...
    


if typing.TYPE_CHECKING:
    RequestData = bytes | Iterable[bytes] | typing.IO | None
    Preference = typing.Callable[[RequestHandler, Request], int]
_RH_PREFERENCES: set[Preference] = ...
