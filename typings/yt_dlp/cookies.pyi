"""
This type stub file was generated by pyright.
"""

import contextlib
import http.cookiejar
import http.cookies
from enum import Enum
from .minicurses import MultilinePrinter
from .utils import YoutubeDLError
from .utils._utils import _YDLLogger

CHROMIUM_BASED_BROWSERS = ...
SUPPORTED_BROWSERS = ...
class YDLLogger(_YDLLogger):
    def warning(self, message, only_once=...): # -> None:
        ...
    
    class ProgressBar(MultilinePrinter):
        def print(self, message): # -> None:
            ...
        
    
    
    def progress_bar(self): # -> ProgressBar | None:
        """Return a context manager with a print method. (Optional)"""
        ...
    


class CookieLoadError(YoutubeDLError):
    ...


def load_cookies(cookie_file, browser_specification, ydl): # -> YoutubeDLCookieJar:
    ...

def extract_cookies_from_browser(browser_name, profile=..., logger=..., *, keyring=..., container=...): # -> YoutubeDLCookieJar:
    ...

class ChromeCookieDecryptor:
    """
    Overview:

        Linux:
        - cookies are either v10 or v11
            - v10: AES-CBC encrypted with a fixed key
                - also attempts empty password if decryption fails
            - v11: AES-CBC encrypted with an OS protected key (keyring)
                - also attempts empty password if decryption fails
            - v11 keys can be stored in various places depending on the activate desktop environment [2]

        Mac:
        - cookies are either v10 or not v10
            - v10: AES-CBC encrypted with an OS protected key (keyring) and more key derivation iterations than linux
            - not v10: 'old data' stored as plaintext

        Windows:
        - cookies are either v10 or not v10
            - v10: AES-GCM encrypted with a key which is encrypted with DPAPI
            - not v10: encrypted with DPAPI

    Sources:
    - [1] https://chromium.googlesource.com/chromium/src/+/refs/heads/main/components/os_crypt/
    - [2] https://chromium.googlesource.com/chromium/src/+/refs/heads/main/components/os_crypt/sync/key_storage_linux.cc
        - KeyStorageLinux::CreateService
    """
    _cookie_counts = ...
    def decrypt(self, encrypted_value):
        ...
    


def get_cookie_decryptor(browser_root, browser_keyring_name, logger, *, keyring=..., meta_version=...): # -> WindowsChromeCookieDecryptor | LinuxChromeCookieDecryptor:
    ...

class LinuxChromeCookieDecryptor(ChromeCookieDecryptor):
    def __init__(self, browser_keyring_name, logger, *, keyring=..., meta_version=...) -> None:
        ...
    
    @staticmethod
    def derive_key(password): # -> bytes:
        ...
    
    def decrypt(self, encrypted_value): # -> str | None:
        """

        following the same approach as the fix in [1]: if cookies fail to decrypt then attempt to decrypt
        with an empty password. The failure detection is not the same as what chromium uses so the
        results won't be perfect

        References:
            - [1] https://chromium.googlesource.com/chromium/src/+/bbd54702284caca1f92d656fdcadf2ccca6f4165%5E%21/
                - a bugfix to try an empty password as a fallback
        """
        ...
    


class MacChromeCookieDecryptor(ChromeCookieDecryptor):
    def __init__(self, browser_keyring_name, logger, meta_version=...) -> None:
        ...
    
    @staticmethod
    def derive_key(password): # -> bytes:
        ...
    
    def decrypt(self, encrypted_value): # -> str | None:
        ...
    


class WindowsChromeCookieDecryptor(ChromeCookieDecryptor):
    def __init__(self, browser_root, logger, meta_version=...) -> None:
        ...
    
    def decrypt(self, encrypted_value): # -> str | None:
        ...
    


class ParserError(Exception):
    ...


class DataParser:
    def __init__(self, data, logger) -> None:
        ...
    
    def read_bytes(self, num_bytes):
        ...
    
    def expect_bytes(self, expected_value, message): # -> None:
        ...
    
    def read_uint(self, big_endian=...): # -> Any:
        ...
    
    def read_double(self, big_endian=...): # -> Any:
        ...
    
    def read_cstring(self): # -> str:
        ...
    
    def skip(self, num_bytes, description=...): # -> None:
        ...
    
    def skip_to(self, offset, description=...): # -> None:
        ...
    
    def skip_to_end(self, description=...): # -> None:
        ...
    


def parse_safari_cookies(data, jar=..., logger=...): # -> YoutubeDLCookieJar:
    """
    References:
        - https://github.com/libyal/dtformats/blob/main/documentation/Safari%20Cookies.asciidoc
            - this data appears to be out of date but the important parts of the database structure is the same
            - there are a few bytes here and there which are skipped during parsing
    """
    ...

class _LinuxDesktopEnvironment(Enum):
    """
    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/base/nix/xdg_util.h
    DesktopEnvironment
    """
    OTHER = ...
    CINNAMON = ...
    DEEPIN = ...
    GNOME = ...
    KDE3 = ...
    KDE4 = ...
    KDE5 = ...
    KDE6 = ...
    PANTHEON = ...
    UKUI = ...
    UNITY = ...
    XFCE = ...
    LXQT = ...


class _LinuxKeyring(Enum):
    """
    https://chromium.googlesource.com/chromium/src/+/refs/heads/main/components/os_crypt/sync/key_storage_util_linux.h
    SelectedLinuxBackend
    """
    KWALLET = ...
    KWALLET5 = ...
    KWALLET6 = ...
    GNOMEKEYRING = ...
    BASICTEXT = ...


SUPPORTED_KEYRINGS = ...
def pbkdf2_sha1(password, salt, iterations, key_length): # -> bytes:
    ...

class LenientSimpleCookie(http.cookies.SimpleCookie):
    """More lenient version of http.cookies.SimpleCookie"""
    _LEGAL_KEY_CHARS = ...
    _LEGAL_VALUE_CHARS = ...
    _RESERVED = ...
    _FLAGS = ...
    _COOKIE_PATTERN = ...
    def load(self, data): # -> None:
        ...
    


class YoutubeDLCookieJar(http.cookiejar.MozillaCookieJar):
    """
    See [1] for cookie file format.

    1. https://curl.haxx.se/docs/http-cookies.html
    """
    _HTTPONLY_PREFIX = ...
    _ENTRY_LEN = ...
    _HEADER = ...
    _CookieFileEntry = ...
    def __init__(self, filename=..., *args, **kwargs) -> None:
        ...
    
    @contextlib.contextmanager
    def open(self, file, *, write=...): # -> Generator[TextIOWrapper | Unknown, Any, None]:
        ...
    
    def save(self, filename=..., ignore_discard=..., ignore_expires=...): # -> None:
        """
        Save cookies to a file.
        Code is taken from CPython 3.6
        https://github.com/python/cpython/blob/8d999cbf4adea053be6dbb612b9844635c4dfb8e/Lib/http/cookiejar.py#L2091-L2117 """
        ...
    
    def load(self, filename=..., ignore_discard=..., ignore_expires=...): # -> None:
        """Load cookies from a file."""
        ...
    
    def get_cookie_header(self, url): # -> str | None:
        """Generate a Cookie HTTP header for a given url"""
        ...
    
    def get_cookies_for_url(self, url):
        """Generate a list of Cookie objects for a given url"""
        ...
    
    def clear(self, *args, **kwargs): # -> None:
        ...
    


