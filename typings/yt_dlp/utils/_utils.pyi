"""
This type stub file was generated by pyright.
"""

import collections
import collections.abc
import functools
import html.parser
import json
import netrc
import platform
import subprocess
import sys
import types
import ctypes

__name__ = ...
class NO_DEFAULT:
    ...


def IDENTITY(x):
    ...

ENGLISH_MONTH_NAMES = ...
MONTH_NAMES = ...
TIMEZONE_NAMES = ...
ACCENT_CHARS = ...
DATE_FORMATS = ...
DATE_FORMATS_DAY_FIRST = ...
DATE_FORMATS_MONTH_FIRST = ...
PACKED_CODES_RE = ...
JSON_LD_RE = ...
NUMBER_RE = ...
@functools.cache
def preferredencoding(): # -> str:
    """Get preferred encoding.

    Returns the best encoding scheme for the system, based on
    locale.getpreferredencoding() and some further tweaks.
    """
    ...

def write_json_file(obj, fn): # -> None:
    """ Encode obj as JSON and write it to fn, atomically if possible """
    ...

def partial_application(func): # -> _Wrapped[..., Unknown, (*args: Unknown, **kwargs: Unknown), partial[Unknown] | Unknown]:
    ...

def find_xpath_attr(node, xpath, key, val=...):
    """ Find the xpath xpath[@key=val] """
    ...

def xpath_with_ns(path, ns_map): # -> LiteralString:
    ...

def xpath_element(node, xpath, name=..., fatal=..., default=...): # -> type[NO_DEFAULT] | None:
    ...

def xpath_text(node, xpath, name=..., fatal=..., default=...): # -> type[NO_DEFAULT] | None:
    ...

def xpath_attr(node, xpath, key, name=..., fatal=..., default=...): # -> type[NO_DEFAULT] | None:
    ...

def get_element_by_id(id, html, **kwargs): # -> str | None:
    """Return the content of the tag with the specified ID in the passed HTML document"""
    ...

def get_element_html_by_id(id, html, **kwargs): # -> None:
    """Return the html of the tag with the specified ID in the passed HTML document"""
    ...

def get_element_by_class(class_name, html): # -> str | None:
    """Return the content of the first tag with the specified class in the passed HTML document"""
    ...

def get_element_html_by_class(class_name, html): # -> None:
    """Return the html of the first tag with the specified class in the passed HTML document"""
    ...

def get_element_by_attribute(attribute, value, html, **kwargs): # -> str | None:
    ...

def get_element_html_by_attribute(attribute, value, html, **kargs): # -> None:
    ...

def get_elements_by_class(class_name, html, **kargs): # -> list[str | None]:
    """Return the content of all tags with the specified class in the passed HTML document as a list"""
    ...

def get_elements_html_by_class(class_name, html): # -> list[Unknown]:
    """Return the html of all tags with the specified class in the passed HTML document as a list"""
    ...

def get_elements_by_attribute(*args, **kwargs): # -> list[str | None]:
    """Return the content of the tag with the specified attribute in the passed HTML document"""
    ...

def get_elements_html_by_attribute(*args, **kwargs): # -> list[Unknown]:
    """Return the html of the tag with the specified attribute in the passed HTML document"""
    ...

def get_elements_text_and_html_by_attribute(attribute, value, html, *, tag=..., escape_value=...): # -> Generator[tuple[str | None, Unknown], Any, None]:
    """
    Return the text (content) and the html (whole) of the tag with the specified
    attribute in the passed HTML document
    """
    ...

class HTMLBreakOnClosingTagParser(html.parser.HTMLParser):
    """
    HTML parser which raises HTMLBreakOnClosingTagException upon reaching the
    closing tag for the first opening tag it has encountered, and can be used
    as a context manager
    """
    class HTMLBreakOnClosingTagException(Exception):
        ...
    
    
    def __init__(self) -> None:
        ...
    
    def __enter__(self): # -> Self@HTMLBreakOnClosingTagParser:
        ...
    
    def __exit__(self, *_): # -> None:
        ...
    
    def close(self): # -> None:
        ...
    
    def handle_starttag(self, tag, _): # -> None:
        ...
    
    def handle_endtag(self, tag): # -> None:
        ...
    


def get_element_text_and_html_by_tag(tag, html): # -> tuple[Unknown, Unknown]:
    """
    For the first element with the specified tag in the passed HTML document
    return its' content (text) and the whole element (html)
    """
    ...

class HTMLAttributeParser(html.parser.HTMLParser):
    """Trivial HTML parser to gather the attributes for a single element"""
    def __init__(self) -> None:
        ...
    
    def handle_starttag(self, tag, attrs):
        ...
    


class HTMLListAttrsParser(html.parser.HTMLParser):
    """HTML parser to gather the attributes for the elements of a list"""
    def __init__(self) -> None:
        ...
    
    def handle_starttag(self, tag, attrs): # -> None:
        ...
    
    def handle_endtag(self, tag): # -> None:
        ...
    


def extract_attributes(html_element): # -> dict[str, str | None]:
    """Given a string for an HTML element such as
    <el
         a="foo" B="bar" c="&98;az" d=boz
         empty= noval entity="&amp;"
         sq='"' dq="'"
    >
    Decode and return a dictionary of attributes.
    {
        'a': 'foo', 'b': 'bar', c: 'baz', d: 'boz',
        'empty': '', 'noval': None, 'entity': '&',
        'sq': '"', 'dq': '\''
    }.
    """
    ...

def parse_list(webpage): # -> list[Unknown]:
    """Given a string for an series of HTML <li> elements,
    return a dictionary of their attributes"""
    ...

def clean_html(html): # -> str:
    """Clean an HTML snippet into a readable string"""
    ...

class LenientJSONDecoder(json.JSONDecoder):
    def __init__(self, *args, transform_source=..., ignore_extra=..., close_objects=..., **kwargs) -> None:
        ...
    
    def decode(self, s): # -> Any:
        ...
    


def sanitize_open(filename, open_mode): # -> tuple[BinaryIO | TextIO, Literal['-']] | tuple[Unknown, Unknown | str] | None:
    """Try to open the given filename, and slightly tweak it if this fails.

    Attempts to open the given filename. If this fails, it tries to change
    the filename slightly, step by step, until it's either able to open it
    or it fails and raises a final exception, like the standard open()
    function.

    It returns the tuple (stream, definitive_file_name).
    """
    ...

def timeconvert(timestr): # -> int | None:
    """Convert RFC 2822 defined time string into system timestamp"""
    ...

def sanitize_filename(s, restricted=..., is_id=...): # -> str:
    """Sanitizes a string so it could be used as part of a filename.
    @param restricted   Use a stricter subset of allowed characters
    @param is_id        Whether this is an ID that should be kept unchanged if possible.
                        If unset, yt-dlp's new sanitization rules are in effect
    """
    ...

def sanitize_path(s, force=...): # -> str:
    """Sanitizes and normalizes path on Windows"""
    ...

def sanitize_url(url, *, scheme=...): # -> str | None:
    ...

def extract_basic_auth(url): # -> tuple[Unknown, None] | tuple[Literal[b""], str]:
    ...

def expand_path(s):
    """Expand shell variables and ~"""
    ...

def orderedSet(iterable, *, lazy=...): # -> Generator[Unknown, Any, None] | list[Unknown]:
    """Remove all duplicates from the input iterable"""
    ...

def unescapeHTML(s): # -> str | None:
    ...

def escapeHTML(text):
    ...

class netrc_from_content(netrc.netrc):
    def __init__(self, content) -> None:
        ...
    


class Popen(subprocess.Popen):
    if sys.platform == 'win32':
        _startupinfo = ...
    else:
        ...
    def __init__(self, args, *remaining, env=..., text=..., shell=..., **kwargs) -> None:
        ...
    
    def communicate_or_kill(self, *args, **kwargs): # -> tuple[Unknown, Unknown]:
        ...
    
    def kill(self, *, timeout=...): # -> None:
        ...
    
    @classmethod
    def run(cls, *args, timeout=..., **kwargs): # -> tuple[Unknown | Literal['', b""], Unknown | Literal['', b""], int | Any]:
        ...
    


def encodeArgument(s): # -> str:
    ...

_timetuple = ...
def timetuple_from_msec(msec): # -> Time:
    ...

def formatSeconds(secs, delim=..., msec=...): # -> str:
    ...

def bug_reports_message(before=...): # -> str:
    ...

class YoutubeDLError(Exception):
    """Base exception for YoutubeDL errors."""
    msg = ...
    def __init__(self, msg=...) -> None:
        ...
    


class ExtractorError(YoutubeDLError):
    """Error during info extraction."""
    def __init__(self, msg, tb=..., expected=..., cause=..., video_id=..., ie=...) -> None:
        """ tb, if given, is the original traceback (so that it can be printed out).
        If expected is set, this is a normal error message and most likely not a bug in yt-dlp.
        """
        ...
    
    def format_traceback(self): # -> str | None:
        ...
    
    def __setattr__(self, name, value): # -> None:
        ...
    


class UnsupportedError(ExtractorError):
    def __init__(self, url) -> None:
        ...
    


class RegexNotFoundError(ExtractorError):
    """Error when a regex didn't match"""
    ...


class GeoRestrictedError(ExtractorError):
    """Geographic restriction Error exception.

    This exception may be thrown when a video is not available from your
    geographic location due to geographic restrictions imposed by a website.
    """
    def __init__(self, msg, countries=..., **kwargs) -> None:
        ...
    


class UserNotLive(ExtractorError):
    """Error when a channel/user is not live"""
    def __init__(self, msg=..., **kwargs) -> None:
        ...
    


class DownloadError(YoutubeDLError):
    """Download Error exception.

    This exception may be thrown by FileDownloader objects if they are not
    configured to continue on errors. They will contain the appropriate
    error message.
    """
    def __init__(self, msg, exc_info=...) -> None:
        """ exc_info, if given, is the original exception that caused the trouble (as returned by sys.exc_info()). """
        ...
    


class EntryNotInPlaylist(YoutubeDLError):
    """Entry not in playlist exception.

    This exception will be thrown by YoutubeDL when a requested entry
    is not found in the playlist info_dict
    """
    msg = ...


class SameFileError(YoutubeDLError):
    """Same File exception.

    This exception will be thrown by FileDownloader objects if they detect
    multiple files would have to be downloaded to the same file on disk.
    """
    msg = ...
    def __init__(self, filename=...) -> None:
        ...
    


class PostProcessingError(YoutubeDLError):
    """Post Processing exception.

    This exception may be raised by PostProcessor's .run() method to
    indicate an error in the postprocessing task.
    """
    ...


class DownloadCancelled(YoutubeDLError):
    """ Exception raised when the download queue should be interrupted """
    msg = ...


class ExistingVideoReached(DownloadCancelled):
    """ --break-on-existing triggered """
    msg = ...


class RejectedVideoReached(DownloadCancelled):
    """ --break-match-filter triggered """
    msg = ...


class MaxDownloadsReached(DownloadCancelled):
    """ --max-downloads limit has been reached. """
    msg = ...


class ReExtractInfo(YoutubeDLError):
    """ Video info needs to be re-extracted. """
    def __init__(self, msg, expected=...) -> None:
        ...
    


class ThrottledDownload(ReExtractInfo):
    """ Download speed below --throttled-rate. """
    msg = ...
    def __init__(self) -> None:
        ...
    


class UnavailableVideoError(YoutubeDLError):
    """Unavailable Format exception.

    This exception will be thrown when a video is requested
    in a format that is not available for that video.
    """
    msg = ...
    def __init__(self, err=...) -> None:
        ...
    


class ContentTooShortError(YoutubeDLError):
    """Content Too Short exception.

    This exception may be raised by FileDownloader objects when a file they
    download is too small for what the server announced first, indicating
    the connection was probably interrupted.
    """
    def __init__(self, downloaded, expected) -> None:
        ...
    


class XAttrMetadataError(YoutubeDLError):
    def __init__(self, code=..., msg=...) -> None:
        ...
    


class XAttrUnavailableError(YoutubeDLError):
    ...


def is_path_like(f): # -> bool:
    ...

def extract_timezone(date_str, default=...): # -> tuple[Unknown | timedelta | None, Unknown]:
    ...

@partial_application
def parse_iso8601(date_str, delimiter=..., timezone=...): # -> int | None:
    """ Return a UNIX timestamp from the given date """
    ...

def date_formats(day_first=...): # -> list[Literal['%d %B %Y', '%d %b %Y', '%B %d %Y', '%B %dst %Y', '%B %dnd %Y', '%B %drd %Y', '%B %dth %Y', '%b %d %Y', '%b %dst %Y', '%b %dnd %Y', '%b %drd %Y', '%b %dth %Y', '%b %dst %Y %I:%M', '%b %dnd %Y %I:%M', '%b %drd %Y %I:%M', '%b %dth %Y %I:%M', '%Y %m %d', '%Y-%m-%d', '%Y.%m.%d.', '%Y/%m/%d', '%Y/%m/%d %H:%M', '%Y/%m/%d %H:%M:%S', '%Y%m%d%H%M', '%Y%m%d%H%M%S', '%Y%m%d', '%Y-%m-%d %H:%M', '%Y-%m-%d %H:%M:%S', '%Y-%m-%d %H:%M:%S.%f', '%Y-%m-%d %H:%M:%S:%f', '%d.%m.%Y %H:%M', '%d.%m.%Y %H.%M', '%Y-%m-%dT%H:%M:%SZ', '%Y-%m-%dT%H:%M:%S.%fZ', '%Y-%m-%dT%H:%M:%S.%f0Z', '%Y-%m-%dT%H:%M:%S', '%Y-%m-%dT%H:%M:%S.%f', '%Y-%m-%dT%H:%M', '%b %d %Y at %H:%M', '%b %d %Y at %H:%M:%S', '%B %d %Y at %H:%M', '%B %d %Y at %H:%M:%S', '%H:%M %d-%b-%Y']]:
    ...

def unified_strdate(date_str, day_first=...): # -> str | None:
    """Return a string with the date in the format YYYYMMDD"""
    ...

def unified_timestamp(date_str, day_first=...): # -> int | float | None:
    ...

@partial_application
def determine_ext(url, default_ext=...): # -> str:
    ...

def subtitles_filename(filename, sub_lang, sub_format, expected_real_ext=...): # -> str:
    ...

def datetime_from_str(date_str, precision=..., format=...): # -> datetime:
    r"""
    Return a datetime object from a string.
    Supported format:
        (now|today|yesterday|DATE)([+-]\d+(microsecond|second|minute|hour|day|week|month|year)s?)?

    @param format       strftime format of DATE
    @param precision    Round the datetime object: auto|microsecond|second|minute|hour|day
                        auto: round to the unit provided in date_str (if applicable).
    """
    ...

def date_from_str(date_str, format=..., strict=...): # -> _Date:
    r"""
    Return a date object from a string using datetime_from_str

    @param strict  Restrict allowed patterns to "YYYYMMDD" and
                   (now|today|yesterday)(-\d+(day|week|month|year)s?)?
    """
    ...

def datetime_add_months(dt_, months):
    """Increment/Decrement a datetime object by months."""
    ...

def datetime_round(dt_, precision=...): # -> datetime:
    """
    Round a datetime object's time to a specific precision
    """
    ...

def hyphenate_date(date_str): # -> str:
    """
    Convert a date in 'YYYYMMDD' format to 'YYYY-MM-DD' format"""
    ...

class DateRange:
    """Represents a time interval between two dates"""
    def __init__(self, start=..., end=...) -> None:
        """start and end must be strings in the format accepted by date"""
        ...
    
    @classmethod
    def day(cls, day): # -> Self@DateRange:
        """Returns a range that only contains the given day"""
        ...
    
    def __contains__(self, date): # -> bool:
        """Check if the date is in the range"""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    


@functools.cache
def system_identifier(): # -> str:
    ...

@functools.cache
def get_windows_version(): # -> tuple[int, ...]:
    """ Get Windows version. returns () if it's not running on Windows """
    ...

def write_string(s, out=..., encoding=...): # -> None:
    ...

def deprecation_warning(msg, *, printer=..., stacklevel=..., **kwargs): # -> None:
    ...

class LockingUnsupportedError(OSError):
    msg = ...
    def __init__(self) -> None:
        ...
    


if sys.platform == 'win32':
    class OVERLAPPED(ctypes.Structure):
        _fields_ = ...
    
    
    kernel32 = ...
    LockFileEx = ...
    UnlockFileEx = ...
    whole_low = ...
    whole_high = ...
else:
    ...
class locked_file:
    locked = ...
    def __init__(self, filename, mode, block=..., encoding=...) -> None:
        ...
    
    def __enter__(self): # -> Self@locked_file:
        ...
    
    def unlock(self): # -> None:
        ...
    
    def __exit__(self, *_): # -> None:
        ...
    
    open = ...
    close = ...
    def __getattr__(self, attr): # -> Any:
        ...
    
    def __iter__(self): # -> Iterator[str]:
        ...
    


@functools.cache
def get_filesystem_encoding(): # -> str:
    ...

_WINDOWS_QUOTE_TRANS = ...
_CMD_QUOTE_TRANS = ...
def shell_quote(args, *, shell=...): # -> str:
    ...

def smuggle_url(url, data):
    """ Pass additional data in a URL for internal use. """
    ...

def unsmuggle_url(smug_url, default=...): # -> tuple[Unknown, Unknown | None] | tuple[Unknown, Any]:
    ...

def format_decimal_suffix(num, fmt=..., *, factor=...): # -> str | None:
    """ Formats numbers with decimal sufixes like K, M, etc """
    ...

def format_bytes(bytes): # -> str:
    ...

def lookup_unit_table(unit_table, s, strict=...): # -> None:
    ...

def parse_bytes(s): # -> None:
    """Parse a string indicating a byte quantity into an integer"""
    ...

def parse_filesize(s): # -> None:
    ...

def parse_count(s): # -> <subclass of str and int> | int | None:
    ...

def parse_resolution(s, *, lenient=...): # -> dict[Unknown, Unknown] | dict[str, int]:
    ...

def parse_bitrate(s): # -> int | None:
    ...

def month_by_name(name, lang=...): # -> int | None:
    """ Return the number of a month by (locale-independently) English name """
    ...

def month_by_abbreviation(abbrev): # -> int | None:
    """ Return the number of a month by (locale-independently) English
        abbreviations """
    ...

def fix_xml_ampersands(xml_str): # -> str:
    """Replace all the '&' by '&amp;' in XML"""
    ...

def setproctitle(title): # -> None:
    ...

def remove_start(s, start):
    ...

def remove_end(s, end):
    ...

def remove_quotes(s):
    ...

def get_domain(url): # -> None:
    """
    This implementation is inconsistent, but is kept for compatibility.
    Use this only for "webpage_url_domain"
    """
    ...

def url_basename(url):
    ...

def base_url(url): # -> str:
    ...

@partial_application
def urljoin(base, path): # -> str | None:
    ...

@partial_application
def int_or_none(v, scale=..., default=..., get_attr=..., invscale=..., base=...): # -> int | None:
    ...

def str_or_none(v, default=...): # -> str | None:
    ...

def str_to_int(int_str): # -> int | None:
    """ A more relaxed version of int_or_none """
    ...

@partial_application
def float_or_none(v, scale=..., invscale=..., default=...): # -> float | None:
    ...

def bool_or_none(v, default=...): # -> bool | None:
    ...

def strip_or_none(v, default=...): # -> str | None:
    ...

def url_or_none(url): # -> str | None:
    ...

def strftime_or_none(timestamp, date_format=..., default=...): # -> str | None:
    ...

def parse_duration(s): # -> float | Literal[0] | None:
    ...

prepend_extension = ...
replace_extension = ...
def check_executable(exe, args=...): # -> Literal[False]:
    """ Checks if the given binary is installed somewhere in PATH, and returns its name.
    args can be a list of arguments for a short output (like -version) """
    ...

def detect_exe_version(output, version_re=..., unrecognized=...): # -> str | Any:
    ...

def get_exe_version(exe, args=..., version_re=..., unrecognized=...): # -> str | Any | Literal[False, b""]:
    """ Returns the version of the specified executable,
    or False if the executable is not present """
    ...

def frange(start=..., stop=..., step=...): # -> Generator[int, Any, None]:
    """Float range"""
    ...

class LazyList(collections.abc.Sequence):
    """Lazy immutable list from an iterable
    Note that slices of a LazyList are lists and not LazyList"""
    class IndexError(IndexError):
        ...
    
    
    def __init__(self, iterable, *, reverse=..., _cache=...) -> None:
        ...
    
    def __iter__(self): # -> Generator[Unknown, Unknown, None]:
        ...
    
    def exhaust(self): # -> list[Unknown]:
        """Evaluate the entire iterable"""
        ...
    
    def __getitem__(self, idx):
        ...
    
    def __bool__(self): # -> bool:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def __reversed__(self): # -> Self@LazyList:
        ...
    
    def __copy__(self): # -> Self@LazyList:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __str__(self) -> str:
        ...
    


class PagedList:
    class IndexError(IndexError):
        ...
    
    
    def __len__(self): # -> int:
        ...
    
    def __init__(self, pagefunc, pagesize, use_cache=...) -> None:
        ...
    
    def getpage(self, pagenum): # -> list[Unknown]:
        ...
    
    def getslice(self, start=..., end=...): # -> list[Unknown]:
        ...
    
    def __getitem__(self, idx):
        ...
    
    def __bool__(self): # -> bool:
        ...
    


class OnDemandPagedList(PagedList):
    """Download pages until a page with less than maximum results"""
    ...


class InAdvancePagedList(PagedList):
    """PagedList with total number of pages known in advance"""
    def __init__(self, pagefunc, pagecount, pagesize) -> None:
        ...
    


class PlaylistEntries:
    MissingEntry = ...
    is_exhausted = ...
    def __init__(self, ydl, info_dict) -> None:
        ...
    
    PLAYLIST_ITEMS_RE = ...
    @classmethod
    def parse_playlist_items(cls, string): # -> Generator[slice | int, Any, None]:
        ...
    
    def get_requested_items(self): # -> Generator[tuple[int, object | Unknown], Any, None]:
        ...
    
    def get_full_count(self): # -> int | Unknown | None:
        ...
    
    def __getitem__(self, idx): # -> Generator[tuple[int, object | Unknown], Any, None]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    class IndexError(IndexError):
        ...
    
    


def uppercase_escape(s): # -> str:
    ...

def lowercase_escape(s): # -> str:
    ...

def parse_qs(url, **kwargs): # -> dict[Unknown, list[Unknown]]:
    ...

def read_batch_urls(batch_fd): # -> list[str | Any | bool]:
    ...

def urlencode_postdata(*args, **kargs): # -> bytes:
    ...

@partial_application
def update_url(url, *, query_update=..., **kwargs): # -> str:
    """Replace URL components specified by kwargs
       @param url           str or parse url tuple
       @param query_update  update query
       @returns             str
    """
    ...

@partial_application
def update_url_query(url, query): # -> str:
    ...

def multipart_encode(data, boundary=...): # -> tuple[Unknown, str]:
    """
    Encode a dict to RFC 7578-compliant form-data

    data:
        A dict where keys and values can be either Unicode or bytes-like
        objects.
    boundary:
        If specified a Unicode object, it's used as the boundary. Otherwise
        a random boundary is generated.

    Reference: https://tools.ietf.org/html/rfc7578
    """
    ...

def is_iterable_like(x, allowed_types=..., blocked_types=...): # -> bool:
    ...

def variadic(x, allowed_types=...): # -> tuple[Unknown]:
    ...

def try_call(*funcs, expected_type=..., args=..., kwargs=...): # -> None:
    ...

def try_get(src, getter, expected_type=...): # -> None:
    ...

def filter_dict(dct, cndn=...): # -> dict[Unknown, Unknown]:
    ...

def merge_dicts(*dicts): # -> dict[Unknown, Unknown]:
    ...

def encode_compat_str(string, encoding=..., errors=...): # -> str:
    ...

US_RATINGS = ...
TV_PARENTAL_GUIDELINES = ...
def parse_age_limit(s): # -> int | None:
    ...

def strip_jsonp(code): # -> str:
    ...

def js_to_json(code, vars=..., *, strict=...): # -> str:
    ...

def qualities(quality_ids): # -> (qid: Unknown) -> (Unknown | Literal[-1]):
    """ Get a numeric quality value out of a list of possible values """
    ...

POSTPROCESS_WHEN = ...
DEFAULT_OUTTMPL = ...
OUTTMPL_TYPES = ...
STR_FORMAT_RE_TMPL = ...
STR_FORMAT_TYPES = ...
def limit_length(s, length): # -> None:
    """ Add ellipses to overly long strings """
    ...

def version_tuple(v): # -> tuple[int, ...]:
    ...

def is_outdated_version(version, limit, assume_new=...): # -> bool:
    ...

def ytdl_is_updateable(): # -> bool:
    """ Returns if yt-dlp can be updated with -U """
    ...

def args_to_str(args): # -> str:
    ...

def error_to_str(err): # -> str:
    ...

@partial_application
def mimetype2ext(mt, default=...): # -> type[NO_DEFAULT] | list[Unknown] | dict[Unknown, Unknown] | str | None:
    ...

def ext2mimetype(ext_or_url): # -> str | None:
    ...

def parse_codecs(codecs_str): # -> dict[Unknown, Unknown] | dict[str, Unknown] | dict[str, str]:
    ...

def get_compatible_ext(*, vcodecs, acodecs, vexts, aexts, preferences=...): # -> str:
    ...

def urlhandle_detect_ext(url_handle, default=...): # -> str | type[NO_DEFAULT] | list[Unknown] | dict[Unknown, Unknown] | None:
    ...

def encode_data_uri(data, mime_type): # -> str:
    ...

def age_restricted(content_limit, age_limit): # -> Literal[False]:
    """ Returns True iff the content should be blocked """
    ...

BOMS = ...
def is_html(first_bytes): # -> Match[str] | None:
    """ Detect whether a file contains HTML by examining its first bytes. """
    ...

def determine_protocol(info_dict): # -> bytes | str:
    ...

def render_table(header_row, data, delim=..., extra_gap=..., hide_empty=...): # -> LiteralString:
    """ Render a list of rows, each as a list of values.
    Text after a \t will be right aligned """
    ...

def match_str(filter_str, dct, incomplete=...): # -> bool:
    """ Filter a dictionary with a simple string syntax.
    @returns           Whether the filter passes
    @param incomplete  Set of keys that is expected to be missing from dct.
                       Can be True/False to indicate all/none of the keys may be missing.
                       All conditions on incomplete keys pass if the key is missing
    """
    ...

def match_filter_func(filters, breaking_filters=...): # -> function_with_repr | None:
    ...

class download_range_func:
    def __init__(self, chapters, ranges, from_info=...) -> None:
        ...
    
    def __call__(self, info_dict, ydl): # -> Generator[dict[str, int] | dict[str, int | Unknown] | dict[str, Unknown], Any, None]:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    


def parse_dfxp_time_expr(time_expr): # -> float | None:
    ...

def srt_subtitles_timecode(seconds): # -> LiteralString:
    ...

def ass_subtitles_timecode(seconds): # -> LiteralString:
    ...

def dfxp2srt(dfxp_data): # -> LiteralString:
    """
    @param dfxp_data A bytes-like object containing DFXP data
    @returns A unicode object containing converted SRT data
    """
    class TTMLPElementParser:
        ...
    
    

def cli_option(params, command_option, param, separator=...): # -> list[Unknown] | list[str]:
    ...

def cli_bool_option(params, command_option, param, true_value=..., false_value=..., separator=...): # -> list[Unknown] | list[str]:
    ...

def cli_valueless_option(params, command_option, param, expected_value=...): # -> list[Unknown]:
    ...

def cli_configuration_args(argdict, keys, default=..., use_compat=...): # -> list[Unknown] | tuple[Unknown, ...]:
    ...

class ISO639Utils:
    _lang_map = ...
    @classmethod
    def short2long(cls, code): # -> str | None:
        """Convert language code from ISO 639-1 to ISO 639-2/T"""
        ...
    
    @classmethod
    def long2short(cls, code): # -> str | None:
        """Convert language code from ISO 639-2/T to ISO 639-1"""
        ...
    


class ISO3166Utils:
    _country_map = ...
    @classmethod
    def short2full(cls, code): # -> str | None:
        """Convert an ISO 3166-2 country code to the corresponding full name"""
        ...
    


class GeoUtils:
    _country_ip_map = ...
    @classmethod
    def random_ipv4(cls, code_or_block): # -> str | None:
        ...
    


def long_to_bytes(n, blocksize=...): # -> bytes:
    """long_to_bytes(n:long, blocksize:int) : string
    Convert a long integer to a byte string.

    If optional blocksize is given and greater than zero, pad the front of the
    byte string with binary zeros so that the length is a multiple of
    blocksize.
    """
    ...

def bytes_to_long(s): # -> Any | Literal[0]:
    """bytes_to_long(string) : long
    Convert a byte string to a long integer.

    This is (essentially) the inverse of long_to_bytes().
    """
    ...

def ohdave_rsa_encrypt(data, exponent, modulus): # -> str:
    """
    Implement OHDave's RSA algorithm. See http://www.ohdave.com/rsa/

    Input:
        data: data to encrypt, bytes-like object
        exponent, modulus: parameter e and N of RSA algorithm, both integer
    Output: hex string of encrypted data

    Limitation: supports one block encryption only
    """
    ...

def pkcs1pad(data, length): # -> list[Unknown]:
    """
    Padding input data with PKCS#1 scheme

    @param {int[]} data        input data
    @param {int}   length      target length
    @returns {int[]}           padded data
    """
    ...

def encode_base_n(num, n=..., table=...): # -> str:
    """Convert given int to a base-n string"""
    ...

def decode_base_n(string, n=..., table=...): # -> int:
    """Convert given base-n string to int"""
    ...

def decode_packed_codes(code): # -> str:
    ...

def caesar(s, alphabet, shift): # -> LiteralString:
    ...

def rot47(s):
    ...

def parse_m3u8_attributes(attrib): # -> dict[Unknown, Unknown]:
    ...

def urshift(val, n):
    ...

def write_xattr(path, key, value): # -> None:
    ...

def random_birthday(year_field, month_field, day_field): # -> dict[Unknown, str]:
    ...

def find_available_port(interface=...): # -> _RetAddress | None:
    ...

DOT_URL_LINK_TEMPLATE = ...
DOT_WEBLOC_LINK_TEMPLATE = ...
DOT_DESKTOP_LINK_TEMPLATE = ...
LINK_TEMPLATES = ...
def iri_to_uri(iri): # -> str:
    """
    Converts an IRI (Internationalized Resource Identifier, allowing Unicode characters) to a URI (Uniform Resource Identifier, ASCII-only).

    The function doesn't add an additional layer of escaping; e.g., it doesn't escape `%3C` as `%253C`. Instead, it percent-escapes characters with an underlying UTF-8 encoding *besides* those already escaped, leaving the URI intact.
    """
    ...

def to_high_limit_path(path):
    ...

@partial_application
def format_field(obj, field=..., template=..., ignore=..., default=..., func=...): # -> str:
    ...

def clean_podcast_url(url): # -> str:
    ...

_HEX_TABLE = ...
def random_uuidv4(): # -> str:
    ...

def make_dir(path, to_screen=...): # -> bool:
    ...

def get_executable_path(): # -> str:
    ...

def get_user_config_dirs(package_name): # -> Generator[str, Any, None]:
    ...

def get_system_config_dirs(package_name): # -> Generator[str, Any, None]:
    ...

def time_seconds(**kwargs): # -> float:
    """
    Returns TZ-aware time in seconds since the epoch (1970-01-01T00:00:00Z)
    """
    ...

def jwt_encode_hs256(payload_data, key, headers=...): # -> bytes:
    ...

def jwt_decode_hs256(jwt): # -> Any:
    ...

WINDOWS_VT_MODE = ...
@functools.cache
def supports_terminal_sequences(stream): # -> Literal[False]:
    ...

def windows_enable_vt_mode(): # -> None:
    """Ref: https://bugs.python.org/issue30075 """
    ...

_terminal_sequences_re = ...
def remove_terminal_sequences(string): # -> str:
    ...

def number_of_digits(number): # -> int:
    ...

def join_nonempty(*values, delim=..., from_dict=...): # -> str:
    ...

def scale_thumbnails_to_max_format_width(formats, thumbnails, url_width_re): # -> list[dict[Unknown, Unknown]]:
    """
    Find the largest format dimensions in terms of video width and, for each thumbnail:
    * Modify the URL: Match the width with the provided regex and replace with the former width
    * Update dimensions

    This function is useful with video services that scale the provided thumbnails on demand
    """
    ...

def parse_http_range(range): # -> tuple[None, None, None] | tuple[int, int | Unknown | None, int | Unknown | None]:
    """ Parse value of "Range" or "Content-Range" HTTP header into tuple. """
    ...

def read_stdin(what): # -> TextIO:
    ...

def determine_file_encoding(data): # -> tuple[Unknown, int] | tuple[str | Any | None, Literal[0]]:
    """
    Detect the text encoding used
    @returns (encoding, bytes to skip)
    """
    ...

class Config:
    own_args = ...
    parsed_args = ...
    filename = ...
    __initialized = ...
    _plugin_dirs = ...
    def __init__(self, parser, label=...) -> None:
        ...
    
    def init(self, args=..., filename=...): # -> bool:
        ...
    
    def load_configs(self): # -> bool:
        ...
    
    def __str__(self) -> str:
        ...
    
    @staticmethod
    def read_file(filename, default=...): # -> list[str]:
        ...
    
    @staticmethod
    def hide_login_info(opts): # -> list[str | Any | Unknown]:
        ...
    
    def append_config(self, *args, label=...): # -> None:
        ...
    
    @property
    def all_args(self): # -> Generator[Unknown, Unknown, None]:
        ...
    
    def parse_known_args(self, **kwargs):
        ...
    
    def parse_args(self):
        ...
    


def merge_headers(*dicts): # -> dict[Unknown, Unknown]:
    """Merge dicts of http headers case insensitively, prioritizing the latter ones"""
    ...

def cached_method(f): # -> _Wrapped[..., Unknown, (self: Unknown, *args: Unknown, **kwargs: Unknown), Unknown]:
    """Cache a method"""
    ...

class classproperty:
    """property access for class methods with optional caching"""
    def __new__(cls, func=..., *args, **kwargs): # -> partial[classproperty] | Self@classproperty:
        ...
    
    def __init__(self, func, *, cache=...) -> None:
        ...
    
    def __get__(self, _, cls):
        ...
    


class function_with_repr:
    def __init__(self, func, repr_=...) -> None:
        ...
    
    def __call__(self, *args, **kwargs):
        ...
    
    @classmethod
    def set_repr(cls, repr_): # -> partial[function_with_repr]:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Namespace(types.SimpleNamespace):
    """Immutable namespace"""
    def __iter__(self): # -> Iterator[Any]:
        ...
    
    @property
    def items_(self): # -> dict_items[str, Any]:
        ...
    


MEDIA_EXTENSIONS = ...
KNOWN_EXTENSIONS = ...
class _UnsafeExtensionError(Exception):
    """
    Mitigation exception for uncommon/malicious file extensions
    This should be caught in YoutubeDL.py alongside a warning

    Ref: https://github.com/yt-dlp/yt-dlp/security/advisories/GHSA-79w7-vh3h-8g4j
    """
    ALLOWED_EXTENSIONS = ...
    def __init__(self, extension, /) -> None:
        ...
    
    @classmethod
    def sanitize_extension(cls, extension, /, *, prepend=...): # -> Literal['unknown_video'] | None:
        ...
    


class RetryManager:
    """Usage:
        for retry in RetryManager(...):
            try:
                ...
            except SomeException as err:
                retry.error = err
                continue
    """
    def __init__(self, _retries, _error_callback, **kwargs) -> None:
        ...
    
    @property
    def error(self): # -> None:
        ...
    
    @error.setter
    def error(self, value): # -> None:
        ...
    
    def __iter__(self): # -> Generator[Self@RetryManager, Any, None]:
        ...
    
    @staticmethod
    def report_retry(e, count, retries, *, sleep_func, info, warn, error=..., suffix=...): # -> None:
        """Utility function for reporting retries"""
        ...
    


@partial_application
def make_archive_id(ie, video_id): # -> str:
    ...

@partial_application
def truncate_string(s, left, right=...): # -> str:
    ...

def orderedSet_from_options(options, alias_dict, *, use_regex=..., start=...): # -> Generator[Unknown, Any, None] | list[Unknown]:
    ...

class FormatSorter:
    regex = ...
    default = ...
    _prefer_vp9_sort = ...
    ytdl_default = ...
    settings = ...
    def __init__(self, ydl, field_preference) -> None:
        ...
    
    def evaluate_params(self, params, sort_extractor): # -> None:
        ...
    
    def print_verbose_info(self, write_debug): # -> None:
        ...
    
    def calculate_preference(self, format): # -> tuple[Unknown, ...]:
        ...
    


def filesize_from_tbr(tbr, duration): # -> int | None:
    """
    @param tbr:      Total bitrate in kbps (1000 bits/sec)
    @param duration: Duration in seconds
    @returns         Filesize in bytes
    """
    ...

class _YDLLogger:
    def __init__(self, ydl=...) -> None:
        ...
    
    def debug(self, message): # -> None:
        ...
    
    def info(self, message): # -> None:
        ...
    
    def warning(self, message, *, once=...): # -> None:
        ...
    
    def error(self, message, *, is_error=...): # -> None:
        ...
    
    def stdout(self, message): # -> None:
        ...
    
    def stderr(self, message): # -> None:
        ...
    


