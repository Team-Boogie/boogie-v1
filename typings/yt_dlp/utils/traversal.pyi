"""
This type stub file was generated by pyright.
"""

import collections
import collections.abc
import typing
from ._utils import ExtractorError

def traverse_obj(obj, *paths, default=..., expected_type=..., get_all=..., casesense=..., is_user_input=..., traverse_string=...): # -> list[Unknown] | type[NO_DEFAULT] | dict[Unknown, Unknown] | None:
    """
    Safely traverse nested `dict`s and `Iterable`s

    >>> obj = [{}, {"key": "value"}]
    >>> traverse_obj(obj, (1, "key"))
    'value'

    Each of the provided `paths` is tested and the first producing a valid result will be returned.
    The next path will also be tested if the path branched but no results could be found.
    Supported values for traversal are `Mapping`, `Iterable`, `re.Match`,
    `xml.etree.ElementTree` (xpath) and `http.cookies.Morsel`.
    Unhelpful values (`{}`, `None`) are treated as the absence of a value and discarded.

    The paths will be wrapped in `variadic`, so that `'key'` is conveniently the same as `('key', )`.

    The keys in the path can be one of:
        - `None`:           Return the current object.
        - `set`:            Requires the only item in the set to be a type or function,
                            like `{type}`/`{type, type, ...}`/`{func}`. If a `type`, return only
                            values of this type. If a function, returns `func(obj)`.
        - `str`/`int`:      Return `obj[key]`. For `re.Match`, return `obj.group(key)`.
        - `slice`:          Branch out and return all values in `obj[key]`.
        - `Ellipsis`:       Branch out and return a list of all values.
        - `tuple`/`list`:   Branch out and return a list of all matching values.
                            Read as: `[traverse_obj(obj, branch) for branch in branches]`.
        - `function`:       Branch out and return values filtered by the function.
                            Read as: `[value for key, value in obj if function(key, value)]`.
                            For `Iterable`s, `key` is the index of the value.
                            For `re.Match`es, `key` is the group number (0 = full match)
                            as well as additionally any group names, if given.
        - `dict`:           Transform the current object and return a matching dict.
                            Read as: `{key: traverse_obj(obj, path) for key, path in dct.items()}`.
        - `any`-builtin:    Take the first matching object and return it, resetting branching.
        - `all`-builtin:    Take all matching objects and return them as a list, resetting branching.
        - `filter`-builtin: Return the value if it is truthy, `None` otherwise.

        `tuple`, `list`, and `dict` all support nested paths and branches.

    @params paths           Paths by which to traverse.
    @param default          Value to return if the paths do not match.
                            If the last key in the path is a `dict`, it will apply to each value inside
                            the dict instead, depth first. Try to avoid if using nested `dict` keys.
    @param expected_type    If a `type`, only accept final values of this type.
                            If any other callable, try to call the function on each result.
                            If the last key in the path is a `dict`, it will apply to each value inside
                            the dict instead, recursively. This does respect branching paths.
    @param get_all          If `False`, return the first matching result, otherwise all matching ones.
    @param casesense        If `False`, consider string dictionary keys as case insensitive.

    `traverse_string` is only meant to be used by YoutubeDL.prepare_outtmpl and is not part of the API

    @param traverse_string  Whether to traverse into objects as strings.
                            If `True`, any non-compatible object will first be
                            converted into a string and then traversed into.
                            The return value of that path will be a string instead,
                            not respecting any further branching.


    @returns                The result of the object traversal.
                            If successful, `get_all=True`, and the path branches at least once,
                            then a list of results is returned instead.
                            If no `default` is given and the last path branches, a `list` of results
                            is always returned. If a path ends on a `dict` that result will always be a `dict`.
    """
    ...

def value(value, /): # -> (_: Unknown) -> Unknown:
    ...

def require(name, /, *, expected=...): # -> (value: Unknown) -> Unknown:
    ...

class _RequiredError(ExtractorError):
    ...


@typing.overload
def subs_list_to_dict(*, lang: str | None = ..., ext: str | None = ...) -> collections.abc.Callable[[list[dict]], dict[str, list[dict]]]:
    ...

@typing.overload
def subs_list_to_dict(subs: list[dict] | None, /, *, lang: str | None = ..., ext: str | None = ...) -> dict[str, list[dict]]:
    ...

def subs_list_to_dict(subs: list[dict] | None = ..., /, *, lang=..., ext=...): # -> partial[(list[dict[Unknown, Unknown]]) -> dict[str, list[dict[Unknown, Unknown]]]] | dict[Unknown, list[Unknown]]:
    """
    Convert subtitles from a traversal into a subtitle dict.
    The path should have an `all` immediately before this function.

    Arguments:
    `ext`      The default value for `ext` in the subtitle dict

    In the dict you can set the following additional items:
    `id`       The subtitle id to sort the dict into
    `quality`  The sort order for each subtitle
    """
    ...

@typing.overload
def find_element(*, attr: str, value: str, tag: str | None = ..., html=..., regex=...):
    ...

@typing.overload
def find_element(*, cls: str, html=...):
    ...

@typing.overload
def find_element(*, id: str, tag: str | None = ..., html=..., regex=...):
    ...

@typing.overload
def find_element(*, tag: str, html=..., regex=...):
    ...

def find_element(*, tag=..., id=..., cls=..., attr=..., value=..., html=..., regex=...): # -> partial[str | None] | ((html: Unknown) -> Unknown):
    ...

@typing.overload
def find_elements(*, cls: str, html=...):
    ...

@typing.overload
def find_elements(*, attr: str, value: str, tag: str | None = ..., html=..., regex=...):
    ...

def find_elements(*, tag=..., cls=..., attr=..., value=..., html=..., regex=...): # -> partial[list[str | None]]:
    ...

def trim_str(*, start=..., end=...): # -> (s: Unknown) -> (Unknown | None):
    ...

def unpack(func, **kwargs): # -> _Wrapped[..., Unknown, (items: Unknown), Unknown]:
    ...

def get_first(obj, *paths, **kwargs): # -> list[Unknown] | type[NO_DEFAULT] | dict[Unknown, Unknown] | None:
    ...

def dict_get(d, key_or_keys, default=..., skip_false_values=...): # -> None:
    ...

