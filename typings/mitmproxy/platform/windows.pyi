"""
This type stub file was generated by pyright.
"""

import collections.abc
import contextlib
import socket
import socketserver
import threading
import click
from collections.abc import Callable
from io import BufferedIOBase
from typing import Any, ClassVar

REDIRECT_API_HOST = ...
REDIRECT_API_PORT = ...
logger = ...
def read(rfile: BufferedIOBase) -> Any:
    ...

def write(data, wfile: BufferedIOBase) -> None:
    ...

class Resolver:
    sock: socket.socket | None
    lock: threading.RLock
    def __init__(self) -> None:
        ...
    
    def setup(self): # -> None:
        ...
    
    def original_addr(self, csock: socket.socket): # -> tuple[Any, ...]:
        ...
    


class APIRequestHandler(socketserver.StreamRequestHandler):
    """
    TransparentProxy API: Returns the pickled server address, port tuple
    for each received pickled client address, port tuple.
    """
    server: APIServer
    def handle(self) -> None:
        ...
    


class APIServer(socketserver.ThreadingMixIn, socketserver.TCPServer):
    def __init__(self, proxifier, *args, **kwargs) -> None:
        ...
    


ERROR_INSUFFICIENT_BUFFER = ...
IN6_ADDR = ctypes.c_ubyte * 16
IN4_ADDR = ctypes.c_ubyte * 4
class MIB_TCP6ROW_OWNER_PID(ctypes.Structure):
    _fields_ = ...


def MIB_TCP6TABLE_OWNER_PID(size): # -> _MIB_TCP6TABLE_OWNER_PID:
    class _MIB_TCP6TABLE_OWNER_PID(ctypes.Structure):
        ...
    
    

class MIB_TCPROW_OWNER_PID(ctypes.Structure):
    _fields_ = ...


def MIB_TCPTABLE_OWNER_PID(size): # -> _MIB_TCPTABLE_OWNER_PID:
    class _MIB_TCPTABLE_OWNER_PID(ctypes.Structure):
        ...
    
    

TCP_TABLE_OWNER_PID_CONNECTIONS = ...
class TcpConnectionTable(collections.abc.Mapping):
    DEFAULT_TABLE_SIZE = ...
    def __init__(self) -> None:
        ...
    
    def __getitem__(self, item):
        ...
    
    def __iter__(self): # -> Iterator[Unknown]:
        ...
    
    def __len__(self): # -> int:
        ...
    
    def refresh(self): # -> None:
        ...
    


class Redirect(threading.Thread):
    daemon = ...
    windivert: pydivert.WinDivert
    def __init__(self, handle: Callable[[pydivert.Packet], None], filter: str, layer: pydivert.Layer = ..., flags: pydivert.Flag = ...) -> None:
        ...
    
    def start(self): # -> None:
        ...
    
    def run(self): # -> None:
        ...
    
    def shutdown(self): # -> None:
        ...
    
    def recv(self) -> pydivert.Packet | None:
        """
        Convenience function that receives a packet from the passed handler and handles error codes.
        If the process has been shut down, None is returned.
        """
        ...
    


class RedirectLocal(Redirect):
    trusted_pids: set[int]
    def __init__(self, redirect_request: Callable[[pydivert.Packet], None], filter: str) -> None:
        ...
    
    def handle(self, packet): # -> None:
        ...
    


TConnection = tuple[str, int]
class ClientServerMap:
    """A thread-safe LRU dict."""
    connection_cache_size: ClassVar[int] = ...
    def __init__(self) -> None:
        ...
    
    def __getitem__(self, item: TConnection) -> TConnection:
        ...
    
    def __setitem__(self, key: TConnection, value: TConnection) -> None:
        ...
    


class TransparentProxy:
    """
    Transparent Windows Proxy for mitmproxy based on WinDivert/PyDivert. This module can be used to
    redirect both traffic that is forwarded by the host and traffic originating from the host itself.

    Requires elevated (admin) privileges. Can be started separately by manually running the file.

    How it works:

    (1) First, we intercept all packages that match our filter.
    We both consider traffic that is forwarded by the OS (WinDivert's NETWORK_FORWARD layer) as well
    as traffic sent from the local machine (WinDivert's NETWORK layer). In the case of traffic from
    the local machine, we need to exempt packets sent from the proxy to not create a redirect loop.
    To accomplish this, we use Windows' GetExtendedTcpTable syscall and determine the source
    application's PID.

    For each intercepted package, we
        1. Store the source -> destination mapping (address and port)
        2. Remove the package from the network (by not reinjecting it).
        3. Re-inject the package into the local network stack, but with the destination address
           changed to the proxy.

    (2) Next, the proxy receives the forwarded packet, but does not know the real destination yet
    (which we overwrote with the proxy's address). On Linux, we would now call
    getsockopt(SO_ORIGINAL_DST). We now access the redirect module's API (see APIRequestHandler),
    submit the source information and get the actual destination back (which we stored in 1.1).

    (3) The proxy now establishes the upstream connection as usual.

    (4) Finally, the proxy sends the response back to the client. To make it work, we need to change
    the packet's source address back to the original destination (using the mapping from 1.1),
    to which the client believes it is talking to.

    Limitations:

    - We assume that ephemeral TCP ports are not re-used for multiple connections at the same time.
    The proxy will fail if an application connects to example.com and example.org from
    192.168.0.42:4242 simultaneously. This could be mitigated by introducing unique "meta-addresses"
    which mitmproxy sees, but this would remove the correct client info from mitmproxy.
    """
    local: RedirectLocal | None = ...
    forward: Redirect | None = ...
    response: Redirect
    icmp: Redirect
    proxy_port: int
    filter: str
    client_server_map: ClientServerMap
    def __init__(self, local: bool = ..., forward: bool = ..., proxy_port: int = ..., filter: str | None = ...) -> None:
        ...
    
    @classmethod
    def setup(cls): # -> None:
        ...
    
    def start(self): # -> None:
        ...
    
    def shutdown(self): # -> None:
        ...
    
    def redirect_request(self, packet: pydivert.Packet): # -> None:
        ...
    
    def redirect_response(self, packet: pydivert.Packet): # -> None:
        """
        If the proxy responds to the client, let the client believe the target server sent the
        packets.
        """
        ...
    
    @contextlib.contextmanager
    def exempt(self, pid: int): # -> Generator[None, Any, None]:
        ...
    


if __name__ == "__main__":
    @click.group()
    def cli(): # -> None:
        ...
    
    @cli.command()
    @click.option("--local/--no-local", default=True, help="Redirect the host's own traffic.")
    @click.option("--forward/--no-forward", default=True, help="Redirect traffic that's forwarded by the host.")
    @click.option("--filter", type=str, metavar="WINDIVERT_FILTER", help="Custom WinDivert interception rule.")
    @click.option("-p", "--proxy-port", type=int, metavar="8080", default=8080, help="The port mitmproxy is listening on.")
    def redirect(**options): # -> None:
        """Redirect flows to mitmproxy."""
        ...
    
    @cli.command()
    def connections(): # -> None:
        """List all TCP connections and the associated PIDs."""
        ...
    
