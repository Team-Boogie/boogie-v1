"""
This type stub file was generated by pyright.
"""

from collections.abc import Sequence
from typing import ClassVar, Protocol
from mitmproxy import dns, flow, http, tcp, udp

"""
The following operators are understood:

    ~q          Request
    ~s          Response

Headers:

    Patterns are matched against "name: value" strings. Field names are
    all-lowercase.

    ~a          Asset content-type in response. Asset content types are:
                    text/javascript
                    application/x-javascript
                    application/javascript
                    text/css
                    image/*
                    font/*
                    application/font-*
    ~h rex      Header line in either request or response
    ~hq rex     Header in request
    ~hs rex     Header in response

    ~b rex      Expression in the body of either request or response
    ~bq rex     Expression in the body of request
    ~bs rex     Expression in the body of response
    ~t rex      Shortcut for content-type header.

    ~d rex      Request domain
    ~m rex      Method
    ~u rex      URL
    ~c CODE     Response code.
    rex         Equivalent to ~u rex
"""
def only(*types): # -> (fn: Unknown) -> _Wrapped[..., Unknown, (self: Unknown, flow: Unknown), Unknown | bool]:
    ...

class _Token:
    def dump(self, indent=..., fp=...): # -> None:
        ...
    


class _Action(_Token):
    code: ClassVar[str]
    help: ClassVar[str]
    @classmethod
    def make(klass, s, loc, toks): # -> Self@_Action:
        ...
    


class FErr(_Action):
    code = ...
    help = ...
    def __call__(self, f): # -> bool:
        ...
    


class FMarked(_Action):
    code = ...
    help = ...
    def __call__(self, f): # -> bool:
        ...
    


class FHTTP(_Action):
    code = ...
    help = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> Literal[True]:
        ...
    


class FWebSocket(_Action):
    code = ...
    help = ...
    @only(http.HTTPFlow)
    def __call__(self, f: http.HTTPFlow): # -> bool:
        ...
    


class FTCP(_Action):
    code = ...
    help = ...
    @only(tcp.TCPFlow)
    def __call__(self, f): # -> Literal[True]:
        ...
    


class FUDP(_Action):
    code = ...
    help = ...
    @only(udp.UDPFlow)
    def __call__(self, f): # -> Literal[True]:
        ...
    


class FDNS(_Action):
    code = ...
    help = ...
    @only(dns.DNSFlow)
    def __call__(self, f): # -> Literal[True]:
        ...
    


class FReq(_Action):
    code = ...
    help = ...
    @only(http.HTTPFlow, dns.DNSFlow)
    def __call__(self, f): # -> Literal[True] | None:
        ...
    


class FResp(_Action):
    code = ...
    help = ...
    @only(http.HTTPFlow, dns.DNSFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FAll(_Action):
    code = ...
    help = ...
    def __call__(self, f: flow.Flow): # -> Literal[True]:
        ...
    


class _Rex(_Action):
    flags = ...
    is_binary = ...
    def __init__(self, expr) -> None:
        ...
    


class FAsset(_Action):
    code = ...
    help = ...
    ASSET_TYPES = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FContentType(_Rex):
    code = ...
    help = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FContentTypeRequest(_Rex):
    code = ...
    help = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FContentTypeResponse(_Rex):
    code = ...
    help = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FHead(_Rex):
    code = ...
    help = ...
    flags = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FHeadRequest(_Rex):
    code = ...
    help = ...
    flags = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> Literal[True] | None:
        ...
    


class FHeadResponse(_Rex):
    code = ...
    help = ...
    flags = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> Literal[True] | None:
        ...
    


class FBod(_Rex):
    code = ...
    help = ...
    flags = ...
    @only(http.HTTPFlow, tcp.TCPFlow, udp.UDPFlow, dns.DNSFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FBodRequest(_Rex):
    code = ...
    help = ...
    flags = ...
    @only(http.HTTPFlow, tcp.TCPFlow, udp.UDPFlow, dns.DNSFlow)
    def __call__(self, f): # -> Literal[True] | None:
        ...
    


class FBodResponse(_Rex):
    code = ...
    help = ...
    flags = ...
    @only(http.HTTPFlow, tcp.TCPFlow, udp.UDPFlow, dns.DNSFlow)
    def __call__(self, f): # -> Literal[True] | None:
        ...
    


class FMethod(_Rex):
    code = ...
    help = ...
    flags = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FDomain(_Rex):
    code = ...
    help = ...
    flags = ...
    is_binary = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> bool:
        ...
    


class FUrl(_Rex):
    code = ...
    help = ...
    is_binary = ...
    flags = ...
    @classmethod
    def make(klass, s, loc, toks): # -> Self@FUrl:
        ...
    
    @only(http.HTTPFlow, dns.DNSFlow)
    def __call__(self, f): # -> Match[str] | Literal[False] | None:
        ...
    


class FSrc(_Rex):
    code = ...
    help = ...
    is_binary = ...
    def __call__(self, f): # -> Match[str] | Literal[False] | None:
        ...
    


class FDst(_Rex):
    code = ...
    help = ...
    is_binary = ...
    def __call__(self, f): # -> Match[str] | Literal[False] | None:
        ...
    


class FReplay(_Action):
    code = ...
    help = ...
    def __call__(self, f): # -> bool:
        ...
    


class FReplayClient(_Action):
    code = ...
    help = ...
    def __call__(self, f):
        ...
    


class FReplayServer(_Action):
    code = ...
    help = ...
    def __call__(self, f):
        ...
    


class FMeta(_Rex):
    code = ...
    help = ...
    flags = ...
    is_binary = ...
    def __call__(self, f): # -> Match[str] | None:
        ...
    


class FMarker(_Rex):
    code = ...
    help = ...
    is_binary = ...
    def __call__(self, f):
        ...
    


class FComment(_Rex):
    code = ...
    help = ...
    flags = ...
    is_binary = ...
    def __call__(self, f):
        ...
    


class _Int(_Action):
    def __init__(self, num) -> None:
        ...
    


class FCode(_Int):
    code = ...
    help = ...
    @only(http.HTTPFlow)
    def __call__(self, f): # -> Literal[True] | None:
        ...
    


class FAnd(_Token):
    def __init__(self, lst) -> None:
        ...
    
    def dump(self, indent=..., fp=...): # -> None:
        ...
    
    def __call__(self, f): # -> bool:
        ...
    


class FOr(_Token):
    def __init__(self, lst) -> None:
        ...
    
    def dump(self, indent=..., fp=...): # -> None:
        ...
    
    def __call__(self, f): # -> bool:
        ...
    


class FNot(_Token):
    def __init__(self, itm) -> None:
        ...
    
    def dump(self, indent=..., fp=...): # -> None:
        ...
    
    def __call__(self, f): # -> bool:
        ...
    


filter_unary: Sequence[type[_Action]] = ...
filter_rex: Sequence[type[_Rex]] = ...
filter_int = ...
bnf = ...
class TFilter(Protocol):
    pattern: str
    def __call__(self, f: flow.Flow) -> bool:
        ...
    


def parse(s: str) -> TFilter:
    """
    Parse a filter expression and return the compiled filter function.
    If the filter syntax is invalid, `ValueError` is raised.
    """
    ...

def match(flt: str | TFilter, flow: flow.Flow) -> bool:
    """
    Matches a flow against a compiled filter expression.
    Returns True if matched, False if not.

    If flt is a string, it will be compiled as a filter expression.
    If the expression is invalid, ValueError is raised.
    """
    ...

match_all: TFilter = ...
help = ...
