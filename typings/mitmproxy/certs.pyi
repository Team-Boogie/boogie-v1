"""
This type stub file was generated by pyright.
"""

import contextlib
import datetime
import OpenSSL
from collections.abc import Iterable
from dataclasses import dataclass
from pathlib import Path
from typing import NewType, Optional, Union
from cryptography import x509
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives.asymmetric.types import CertificatePublicKeyTypes
from mitmproxy.coretypes import serializable

logger = ...
CA_EXPIRY = ...
CERT_EXPIRY = ...
DEFAULT_DHPARAM = ...
class Cert(serializable.Serializable):
    """Representation of a (TLS) certificate."""
    _cert: x509.Certificate
    def __init__(self, cert: x509.Certificate) -> None:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __hash__(self) -> int:
        ...
    
    @classmethod
    def from_state(cls, state): # -> Cert:
        ...
    
    def get_state(self): # -> bytes:
        ...
    
    def set_state(self, state): # -> None:
        ...
    
    @classmethod
    def from_pem(cls, data: bytes) -> Cert:
        ...
    
    def to_pem(self) -> bytes:
        ...
    
    @classmethod
    def from_pyopenssl(self, x509: OpenSSL.crypto.X509) -> Cert:
        ...
    
    def to_pyopenssl(self) -> OpenSSL.crypto.X509:
        ...
    
    def public_key(self) -> CertificatePublicKeyTypes:
        ...
    
    def fingerprint(self) -> bytes:
        ...
    
    @property
    def issuer(self) -> list[tuple[str, str]]:
        ...
    
    @property
    def notbefore(self) -> datetime.datetime:
        ...
    
    @property
    def notafter(self) -> datetime.datetime:
        ...
    
    def has_expired(self) -> bool:
        ...
    
    @property
    def subject(self) -> list[tuple[str, str]]:
        ...
    
    @property
    def serial(self) -> int:
        ...
    
    @property
    def is_ca(self) -> bool:
        ...
    
    @property
    def keyinfo(self) -> tuple[str, int]:
        ...
    
    @property
    def cn(self) -> str | None:
        ...
    
    @property
    def organization(self) -> str | None:
        ...
    
    @property
    def altnames(self) -> x509.GeneralNames:
        """
        Get all SubjectAlternativeName DNS altnames.
        """
        ...
    


def create_ca(organization: str, cn: str, key_size: int) -> tuple[rsa.RSAPrivateKeyWithSerialization, x509.Certificate]:
    ...

def dummy_cert(privkey: rsa.RSAPrivateKey, cacert: x509.Certificate, commonname: str | None, sans: Iterable[x509.GeneralName], organization: str | None = ...) -> Cert:
    """
    Generates a dummy certificate.

    privkey: CA private key
    cacert: CA certificate
    commonname: Common name for the generated certificate.
    sans: A list of Subject Alternate Names.
    organization: Organization name for the generated certificate.

    Returns cert if operation succeeded, None if not.
    """
    ...

@dataclass(frozen=True)
class CertStoreEntry:
    cert: Cert
    privatekey: rsa.RSAPrivateKey
    chain_file: Path | None
    chain_certs: list[Cert]
    ...


TCustomCertId = str
TGeneratedCertId = tuple[Optional[str], x509.GeneralNames]
TCertId = Union[TCustomCertId, TGeneratedCertId]
DHParams = NewType("DHParams", bytes)
class CertStore:
    """
    Implements an in-memory certificate store.
    """
    STORE_CAP = ...
    default_privatekey: rsa.RSAPrivateKey
    default_ca: Cert
    default_chain_file: Path | None
    default_chain_certs: list[Cert]
    dhparams: DHParams
    certs: dict[TCertId, CertStoreEntry]
    expire_queue: list[CertStoreEntry]
    def __init__(self, default_privatekey: rsa.RSAPrivateKey, default_ca: Cert, default_chain_file: Path | None, dhparams: DHParams) -> None:
        ...
    
    def expire(self, entry: CertStoreEntry) -> None:
        ...
    
    @staticmethod
    def load_dhparam(path: Path) -> DHParams:
        ...
    
    @classmethod
    def from_store(cls, path: Path | str, basename: str, key_size: int, passphrase: bytes | None = ...) -> CertStore:
        ...
    
    @classmethod
    def from_files(cls, ca_file: Path, dhparam_file: Path, passphrase: bytes | None = ...) -> CertStore:
        ...
    
    @staticmethod
    @contextlib.contextmanager
    def umask_secret(): # -> Generator[None, Any, None]:
        """
        Context to temporarily set umask to its original value bitor 0o77.
        Useful when writing private keys to disk so that only the owner
        will be able to read them.
        """
        ...
    
    @staticmethod
    def create_store(path: Path, basename: str, key_size: int, organization=..., cn=...) -> None:
        ...
    
    def add_cert_file(self, spec: str, path: Path, passphrase: bytes | None = ...) -> None:
        ...
    
    def add_cert(self, entry: CertStoreEntry, *names: str) -> None:
        """
        Adds a cert to the certstore. We register the CN in the cert plus
        any SANs, and also the list of names provided as an argument.
        """
        ...
    
    @staticmethod
    def asterisk_forms(dn: str | x509.GeneralName) -> list[str]:
        """
        Return all asterisk forms for a domain. For example, for www.example.com this will return
        [b"www.example.com", b"*.example.com", b"*.com"]. The single wildcard "*" is omitted.
        """
        ...
    
    def get_cert(self, commonname: str | None, sans: Iterable[x509.GeneralName], organization: str | None = ...) -> CertStoreEntry:
        """
        commonname: Common name for the generated certificate. Must be a
        valid, plain-ASCII, IDNA-encoded domain name.

        sans: A list of Subject Alternate Names.

        organization: Organization name for the generated certificate.
        """
        ...
    


def load_pem_private_key(data: bytes, password: bytes | None) -> rsa.RSAPrivateKey:
    """
    like cryptography's load_pem_private_key, but silently falls back to not using a password
    if the private key is unencrypted.
    """
    ...

