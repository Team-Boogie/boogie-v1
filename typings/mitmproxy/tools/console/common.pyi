"""
This type stub file was generated by pyright.
"""

import enum
import urwid.util
from collections.abc import Iterable
from functools import lru_cache
from mitmproxy import flow

IS_WINDOWS_OR_WSL = ...
def is_keypress(k): # -> Literal[True] | None:
    """
    Is this input event a keypress?
    """
    ...

def highlight_key(text, key, textattr=..., keyattr=...): # -> list[Unknown]:
    ...

KEY_MAX = ...
def format_keyvals(entries: Iterable[tuple[str, None | str | urwid.Widget]], key_format: str = ..., value_format: str = ..., indent: int = ...) -> list[urwid.Columns]:
    """
    Format a list of (key, value) tuples.

    Args:
        entries: The list to format. keys must be strings, values can also be None or urwid widgets.
            The latter makes it possible to use the result of format_keyvals() as a value.
        key_format: The display attribute for the key.
        value_format: The display attribute for the value.
        indent: Additional indent to apply.
    """
    ...

def fcol(s: str, attr: str) -> tuple[str, int, urwid.Text]:
    ...

if urwid.util.detected_encoding:
    SYMBOL_REPLAY = ...
    SYMBOL_RETURN = ...
    SYMBOL_MARK = ...
    SYMBOL_UP = ...
    SYMBOL_DOWN = ...
    SYMBOL_ELLIPSIS = ...
    SYMBOL_FROM_CLIENT = ...
    SYMBOL_TO_CLIENT = ...
else:
    SYMBOL_REPLAY = ...
    SYMBOL_RETURN = ...
    SYMBOL_MARK = ...
    SYMBOL_UP = ...
    SYMBOL_DOWN = ...
    SYMBOL_ELLIPSIS = ...
    SYMBOL_FROM_CLIENT = ...
    SYMBOL_TO_CLIENT = ...
SCHEME_STYLES = ...
HTTP_REQUEST_METHOD_STYLES = ...
HTTP_RESPONSE_CODE_STYLE = ...
class RenderMode(enum.Enum):
    TABLE = ...
    LIST = ...
    DETAILVIEW = ...


def fixlen(s: str, maxlen: int) -> str:
    ...

def fixlen_r(s: str, maxlen: int) -> str:
    ...

def render_marker(marker: str) -> str:
    ...

class TruncatedText(urwid.Widget):
    def __init__(self, text, attr, align=...) -> None:
        ...
    
    def pack(self, size, focus=...): # -> tuple[int, Literal[1]]:
        ...
    
    def rows(self, size, focus=...): # -> Literal[1]:
        ...
    
    def render(self, size, focus=...): # -> TextCanvas:
        ...
    


def truncated_plain(text, attr, align=...): # -> TruncatedText:
    ...

def rle_append_beginning_modify(rle, a_r): # -> None:
    """
    Append (a, r) (unpacked from *a_r*) to BEGINNING of rle.
    Merge with first run when possible

    MODIFIES rle parameter contents. Returns None.
    """
    ...

def colorize_host(host: str): # -> list[Unknown]:
    ...

def colorize_req(s: str): # -> list[Unknown]:
    ...

def colorize_url(url): # -> list[tuple[Literal['error'], int]] | list[Unknown]:
    ...

def format_http_content_type(content_type: str) -> tuple[str, str]:
    ...

def format_duration(duration: float) -> tuple[str, str]:
    ...

def format_size(num_bytes: int) -> tuple[str, str]:
    ...

def format_left_indicators(*, focused: bool, intercepted: bool, timestamp: float): # -> tuple[Literal['fixed'], Literal[10], Text]:
    ...

def format_right_indicators(*, replay: bool, marked: str): # -> tuple[Literal['fixed'], Literal[3], Text]:
    ...

@lru_cache(maxsize=800)
def format_http_flow_list(*, render_mode: RenderMode, focused: bool, marked: str, is_replay: bool, request_method: str, request_scheme: str, request_host: str, request_path: str, request_url: str, request_http_version: str, request_timestamp: float, request_is_push_promise: bool, intercepted: bool, response_code: int | None, response_reason: str | None, response_content_length: int | None, response_content_type: str | None, duration: float | None, error_message: str | None) -> urwid.Widget:
    ...

@lru_cache(maxsize=800)
def format_http_flow_table(*, render_mode: RenderMode, focused: bool, marked: str, is_replay: str | None, request_method: str, request_scheme: str, request_host: str, request_path: str, request_url: str, request_http_version: str, request_timestamp: float, request_is_push_promise: bool, intercepted: bool, response_code: int | None, response_reason: str | None, response_content_length: int | None, response_content_type: str | None, duration: float | None, error_message: str | None) -> urwid.Widget:
    ...

@lru_cache(maxsize=800)
def format_message_flow(*, render_mode: RenderMode, focused: bool, timestamp_start: float, marked: str, protocol: str, client_address, server_address, total_size: int, duration: float | None, error_message: str | None): # -> Pile:
    ...

@lru_cache(maxsize=800)
def format_dns_flow(*, render_mode: RenderMode, focused: bool, intercepted: bool, marked: str, is_replay: str | None, op_code: str, request_timestamp: float, domain: str, type: str, response_code: str | None, response_code_http_equiv: int, answer: str | None, error_message: str, duration: float | None): # -> Pile:
    ...

def format_flow(f: flow.Flow, *, render_mode: RenderMode, hostheader: bool = ..., focused: bool = ...) -> urwid.Widget:
    """
    This functions calls the proper renderer depending on the flow type.
    We also want to cache the renderer output, so we extract all attributes
    relevant for display and call the render with only that. This assures that rows
    are updated if the flow is changed.
    """
    ...

