"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable, Iterable, Iterator, Mapping
from dataclasses import dataclass, fields
from typing import Any, TypeVar
from mitmproxy import flow
from mitmproxy.coretypes import multidict, serializable
from mitmproxy.net.http import cookies, url
from mitmproxy.websocket import WebSocketData

T = TypeVar("T")

class Headers(multidict.MultiDict):
    """
    Header class which allows both convenient access to individual headers as well as
    direct access to the underlying raw data. Provides a full dictionary interface.

    Create headers with keyword arguments:
    >>> h = Headers(host="example.com", content_type="application/xml")

    Headers mostly behave like a normal dict:
    >>> h["Host"]
    "example.com"

    Headers are case insensitive:
    >>> h["host"]
    "example.com"

    Headers can also be created from a list of raw (header_name, header_value) byte tuples:
    >>> h = Headers([
        (b"Host",b"example.com"),
        (b"Accept",b"text/html"),
        (b"accept",b"application/xml")
    ])

    Multiple headers are folded into a single header as per RFC 7230:
    >>> h["Accept"]
    "text/html, application/xml"

    Setting a header removes all existing headers with the same name:
    >>> h["Accept"] = "application/text"
    >>> h["Accept"]
    "application/text"

    `bytes(h)` returns an HTTP/1 header block:
    >>> print(bytes(h))
    Host: example.com
    Accept: application/text

    For full control, the raw header fields can be accessed:
    >>> h.fields

    Caveats:
     - For use with the "Set-Cookie" and "Cookie" headers, either use `Response.cookies` or see `Headers.get_all`.
    """

    def __init__(self, fields: Iterable[tuple[bytes, bytes]] = ..., **headers) -> None:
        """
        *Args:*
         - *fields:* (optional) list of ``(name, value)`` header byte tuples,
           e.g. ``[(b"Host", b"example.com")]``. All names and values must be bytes.
         - *\\*\\*headers:* Additional headers to set. Will overwrite existing values from `fields`.
           For convenience, underscores in header names will be transformed to dashes -
           this behaviour does not extend to other methods.

        If ``**headers`` contains multiple keys that have equal ``.lower()`` representations,
        the behavior is undefined.
        """
        ...
    fields: tuple[tuple[bytes, bytes], ...]
    def __bytes__(self) -> bytes: ...
    def __delitem__(self, key: str | bytes) -> None: ...
    def __iter__(self) -> Iterator[str]: ...
    def get_all(self, name: str | bytes) -> list[str]:
        """
        Like `Headers.get`, but does not fold multiple headers into a single one.
        This is useful for Set-Cookie and Cookie headers, which do not support folding.

        *See also:*
         - <https://tools.ietf.org/html/rfc7230#section-3.2.2>
         - <https://datatracker.ietf.org/doc/html/rfc6265#section-5.4>
         - <https://datatracker.ietf.org/doc/html/rfc7540#section-8.1.2.5>
        """
        ...

    def set_all(self, name: str | bytes, values: Iterable[str | bytes]):  # -> None:
        """
        Explicitly set multiple headers for the given key.
        See `Headers.get_all`.
        """
        ...

    def insert(self, index: int, key: str | bytes, value: str | bytes):  # -> None:
        ...

    def items(
        self, multi=...
    ):  # -> Generator[tuple[str, str], None, None] | tuple[tuple[Unknown, Unknown], ...] | ItemsView[Unknown, Unknown]:
        ...

    def get(self, key: str, default: T = None) -> str | T: ...
    def pop(self, key: str, default: T = None) -> str | T: ...

@dataclass
class MessageData(serializable.Serializable):
    http_version: bytes
    headers: Headers
    content: bytes | None
    trailers: Headers | None
    timestamp_start: float
    timestamp_end: float | None
    if __debug__:
        def __post_init__(self):  # -> None:
            ...

    def set_state(self, state):  # -> None:
        ...

    def get_state(self):  # -> dict[str, Any]:
        ...

    @classmethod
    def from_state(cls, state):  # -> Self@MessageData:
        ...

@dataclass
class RequestData(MessageData):
    host: str
    port: int
    method: bytes
    scheme: bytes
    authority: bytes
    path: bytes
    ...

@dataclass
class ResponseData(MessageData):
    status_code: int
    reason: bytes
    ...

class Message(serializable.Serializable):
    """Base class for `Request` and `Response`."""

    @classmethod
    def from_state(cls, state):  # -> Self@Message:
        ...

    def get_state(self):  # -> dict[str, Any]:
        ...

    def set_state(self, state):  # -> None:
        ...
    data: MessageData
    stream: Callable[[bytes], Iterable[bytes] | bytes] | bool = ...
    @property
    def http_version(self) -> str:
        """
        HTTP version string, for example `HTTP/1.1`.
        """
        ...

    @http_version.setter
    def http_version(self, http_version: str | bytes) -> None: ...
    @property
    def is_http10(self) -> bool: ...
    @property
    def is_http11(self) -> bool: ...
    @property
    def is_http2(self) -> bool: ...
    @property
    def is_http3(self) -> bool: ...
    @property
    def headers(self) -> Headers:
        """
        The HTTP headers.
        """
        ...

    @headers.setter
    def headers(self, h: Headers) -> None: ...
    @property
    def trailers(self) -> Headers | None:
        """
        The [HTTP trailers](https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Trailer).
        """
        ...

    @trailers.setter
    def trailers(self, h: Headers | None) -> None: ...
    @property
    def raw_content(self) -> bytes | None:
        """
        The raw (potentially compressed) HTTP message body.

        In contrast to `Message.content` and `Message.text`, accessing this property never raises.

        *See also:* `Message.content`, `Message.text`
        """
        ...

    @raw_content.setter
    def raw_content(self, content: bytes | None) -> None: ...
    @property
    def content(self) -> bytes | None:
        """
        The uncompressed HTTP message body as bytes.

        Accessing this attribute may raise a `ValueError` when the HTTP content-encoding is invalid.

        *See also:* `Message.raw_content`, `Message.text`
        """
        ...

    @content.setter
    def content(self, value: bytes | None) -> None: ...
    @property
    def text(self) -> str | None:
        """
        The uncompressed and decoded HTTP message body as text.

        Accessing this attribute may raise a `ValueError` when either content-encoding or charset is invalid.

        *See also:* `Message.raw_content`, `Message.content`
        """
        ...

    @text.setter
    def text(self, value: str | None) -> None: ...
    def set_content(self, value: bytes | None) -> None: ...
    def get_content(self, strict: bool = ...) -> bytes | None:
        """
        Similar to `Message.content`, but does not raise if `strict` is `False`.
        Instead, the compressed message body is returned as-is.
        """
        ...

    def set_text(self, text: str | None) -> None: ...
    def get_text(self, strict: bool = ...) -> str | None:
        """
        Similar to `Message.text`, but does not raise if `strict` is `False`.
        Instead, the message body is returned as surrogate-escaped UTF-8.
        """
        ...

    @property
    def timestamp_start(self) -> float:
        """
        *Timestamp:* Headers received.
        """
        ...

    @timestamp_start.setter
    def timestamp_start(self, timestamp_start: float) -> None: ...
    @property
    def timestamp_end(self) -> float | None:
        """
        *Timestamp:* Last byte received.
        """
        ...

    @timestamp_end.setter
    def timestamp_end(self, timestamp_end: float | None):  # -> None:
        ...

    def decode(self, strict: bool = ...) -> None:
        """
        Decodes body based on the current Content-Encoding header, then
        removes the header. If there is no Content-Encoding header, no
        action is taken.

        *Raises:*
         - `ValueError`, when the content-encoding is invalid and strict is True.
        """
        ...

    def encode(self, encoding: str) -> None:
        """
        Encodes body with the given encoding, where e is "gzip", "deflate", "identity", "br", or "zstd".
        Any existing content-encodings are overwritten, the content is not decoded beforehand.

        *Raises:*
         - `ValueError`, when the specified content-encoding is invalid.
        """
        ...

    def json(self, **kwargs: Any) -> Any:
        """
        Returns the JSON encoded content of the response, if any.
        `**kwargs` are optional arguments that will be
        passed to `json.loads()`.

        Will raise if the content can not be decoded and then parsed as JSON.

        *Raises:*
         - `json.decoder.JSONDecodeError` if content is not valid JSON.
         - `TypeError` if the content is not available, for example because the response
            has been streamed.
        """
        ...

class Request(Message):
    """
    An HTTP request.
    """

    data: RequestData
    def __init__(
        self,
        host: str,
        port: int,
        method: bytes,
        scheme: bytes,
        authority: bytes,
        path: bytes,
        http_version: bytes,
        headers: Headers | tuple[tuple[bytes, bytes], ...],
        content: bytes | None,
        trailers: Headers | tuple[tuple[bytes, bytes], ...] | None,
        timestamp_start: float,
        timestamp_end: float | None,
    ) -> None: ...
    def __repr__(self) -> str: ...
    @classmethod
    def make(
        cls,
        method: str,
        url: str,
        content: bytes | str = ...,
        headers: (
            Headers | dict[str | bytes, str | bytes] | Iterable[tuple[bytes, bytes]]
        ) = ...,
    ) -> Request:
        """
        Simplified API for creating request objects.
        """
        ...

    @property
    def first_line_format(self) -> str:
        """
        *Read-only:* HTTP request form as defined in [RFC 7230](https://tools.ietf.org/html/rfc7230#section-5.3).

        origin-form and asterisk-form are subsumed as "relative".
        """
        ...

    @property
    def method(self) -> str:
        """
        HTTP request method, e.g. "GET".
        """
        ...

    @method.setter
    def method(self, val: str | bytes) -> None: ...
    @property
    def scheme(self) -> str:
        """
        HTTP request scheme, which should be "http" or "https".
        """
        ...

    @scheme.setter
    def scheme(self, val: str | bytes) -> None: ...
    @property
    def authority(self) -> str:
        """
        HTTP request authority.

        For HTTP/1, this is the authority portion of the request target
        (in either absolute-form or authority-form).
        For origin-form and asterisk-form requests, this property is set to an empty string.

        For HTTP/2, this is the :authority pseudo header.

        *See also:* `Request.host`, `Request.host_header`, `Request.pretty_host`
        """
        ...

    @authority.setter
    def authority(self, val: str | bytes) -> None: ...
    @property
    def host(self) -> str:
        """
        Target server for this request. This may be parsed from the raw request
        (e.g. from a ``GET http://example.com/ HTTP/1.1`` request line)
        or inferred from the proxy mode (e.g. an IP in transparent mode).

        Setting the host attribute also updates the host header and authority information, if present.

        *See also:* `Request.authority`, `Request.host_header`, `Request.pretty_host`
        """
        ...

    @host.setter
    def host(self, val: str | bytes) -> None: ...
    @property
    def host_header(self) -> str | None:
        """
        The request's host/authority header.

        This property maps to either ``request.headers["Host"]`` or
        ``request.authority``, depending on whether it's HTTP/1.x or HTTP/2.0.

        *See also:* `Request.authority`,`Request.host`, `Request.pretty_host`
        """
        ...

    @host_header.setter
    def host_header(self, val: None | str | bytes) -> None: ...
    @property
    def port(self) -> int:
        """
        Target port.
        """
        ...

    @port.setter
    def port(self, port: int) -> None: ...
    @property
    def path(self) -> str:
        """
        HTTP request path, e.g. "/index.html" or "/index.html?a=b".
        Usually starts with a slash, except for OPTIONS requests, which may just be "*".

        This attribute includes both path and query parts of the target URI
        (see Sections 3.3 and 3.4 of [RFC3986](https://datatracker.ietf.org/doc/html/rfc3986)).
        """
        ...

    @path.setter
    def path(self, val: str | bytes) -> None: ...
    @property
    def url(self) -> str:
        """
        The full URL string, constructed from `Request.scheme`, `Request.host`, `Request.port` and `Request.path`.

        Settings this property updates these attributes as well.
        """
        ...

    @url.setter
    def url(self, val: str | bytes) -> None: ...
    @property
    def pretty_host(self) -> str:
        """
        *Read-only:* Like `Request.host`, but using `Request.host_header` header as an additional (preferred) data source.
        This is useful in transparent mode where `Request.host` is only an IP address.

        *Warning:* When working in adversarial environments, this may not reflect the actual destination
        as the Host header could be spoofed.
        """
        ...

    @property
    def pretty_url(self) -> str:
        """
        *Read-only:* Like `Request.url`, but using `Request.pretty_host` instead of `Request.host`.
        """
        ...

    @property
    def query(self) -> multidict.MultiDictView[str, str]:
        """
        The request query as a mutable mapping view on the request's path.
        For the most part, this behaves like a dictionary.
        Modifications to the MultiDictView update `Request.path`, and vice versa.
        """
        ...

    @query.setter
    def query(self, value):  # -> None:
        ...

    @property
    def cookies(self) -> multidict.MultiDictView[str, str]:
        """
        The request cookies.
        For the most part, this behaves like a dictionary.
        Modifications to the MultiDictView update `Request.headers`, and vice versa.
        """
        ...

    @cookies.setter
    def cookies(self, value):  # -> None:
        ...

    @property
    def path_components(self) -> tuple[str, ...]:
        """
        The URL's path components as a tuple of strings.
        Components are unquoted.
        """
        ...

    @path_components.setter
    def path_components(self, components: Iterable[str]):  # -> None:
        ...

    def anticache(self) -> None:
        """
        Modifies this request to remove headers that might produce a cached response.
        """
        ...

    def anticomp(self) -> None:
        """
        Modify the Accept-Encoding header to only accept uncompressed responses.
        """
        ...

    def constrain_encoding(self) -> None:
        """
        Limits the permissible Accept-Encoding values, based on what we can decode appropriately.
        """
        ...

    @property
    def urlencoded_form(self) -> multidict.MultiDictView[str, str]:
        """
        The URL-encoded form data.

        If the content-type indicates non-form data or the form could not be parsed, this is set to
        an empty `MultiDictView`.

        Modifications to the MultiDictView update `Request.content`, and vice versa.
        """
        ...

    @urlencoded_form.setter
    def urlencoded_form(self, value):  # -> None:
        ...

    @property
    def multipart_form(self) -> multidict.MultiDictView[bytes, bytes]:
        """
        The multipart form data.

        If the content-type indicates non-form data or the form could not be parsed, this is set to
        an empty `MultiDictView`.

        Modifications to the MultiDictView update `Request.content`, and vice versa.
        """
        ...

    @multipart_form.setter
    def multipart_form(self, value: list[tuple[bytes, bytes]]) -> None: ...

class Response(Message):
    """
    An HTTP response.
    """

    data: ResponseData
    def __init__(
        self,
        http_version: bytes,
        status_code: int,
        reason: bytes,
        headers: Headers | tuple[tuple[bytes, bytes], ...],
        content: bytes | None,
        trailers: None | Headers | tuple[tuple[bytes, bytes], ...],
        timestamp_start: float,
        timestamp_end: float | None,
    ) -> None: ...
    def __repr__(self) -> str: ...
    @classmethod
    def make(
        cls,
        status_code: int = ...,
        content: bytes | str = ...,
        headers: (
            Headers | Mapping[str, str | bytes] | Iterable[tuple[bytes, bytes]]
        ) = ...,
    ) -> Response:
        """
        Simplified API for creating response objects.
        """
        ...

    @property
    def status_code(self) -> int:
        """
        HTTP Status Code, e.g. ``200``.
        """
        ...

    @status_code.setter
    def status_code(self, status_code: int) -> None: ...
    @property
    def reason(self) -> str:
        """
        HTTP reason phrase, for example "Not Found".

        HTTP/2 responses do not contain a reason phrase, an empty string will be returned instead.
        """
        ...

    @reason.setter
    def reason(self, reason: str | bytes) -> None: ...
    @property
    def cookies(
        self,
    ) -> multidict.MultiDictView[str, tuple[str, multidict.MultiDict[str, str | None]]]:
        """
        The response cookies. A possibly empty `MultiDictView`, where the keys are cookie
        name strings, and values are `(cookie value, attributes)` tuples. Within
        attributes, unary attributes (e.g. `HTTPOnly`) are indicated by a `None` value.
        Modifications to the MultiDictView update `Response.headers`, and vice versa.

        *Warning:* Changes to `attributes` will not be picked up unless you also reassign
        the `(cookie value, attributes)` tuple directly in the `MultiDictView`.
        """
        ...

    @cookies.setter
    def cookies(self, value):  # -> None:
        ...

    def refresh(self, now=...):  # -> None:
        """
        This fairly complex and heuristic function refreshes a server
        response for replay.

         - It adjusts date, expires, and last-modified headers.
         - It adjusts cookie expiration.
        """
        ...

class HTTPFlow(flow.Flow):
    """
    An HTTPFlow is a collection of objects representing a single HTTP
    transaction.
    """

    request: Request
    response: Response | None = ...
    error: flow.Error | None = ...
    websocket: WebSocketData | None = ...
    def get_state(self) -> serializable.State: ...
    def set_state(self, state: serializable.State) -> None: ...
    def __repr__(self):  # -> str:
        ...

    @property
    def timestamp_start(self) -> float:
        """*Read-only:* An alias for `Request.timestamp_start`."""
        ...

    @property
    def mode(self) -> str: ...
    @mode.setter
    def mode(self, val: str) -> None: ...
    def copy(self):  # -> Self@HTTPFlow:
        ...

__all__ = ["HTTPFlow", "Message", "Request", "Response", "Headers"]
