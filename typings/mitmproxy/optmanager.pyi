"""
This type stub file was generated by pyright.
"""

import contextlib
from collections.abc import Iterable, Sequence
from dataclasses import dataclass
from pathlib import Path
from typing import Any, TextIO

unset = ...
class _Option:
    __slots__ = ...
    def __init__(self, name: str, typespec: type | object, default: Any, help: str, choices: Sequence[str] | None) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def default(self): # -> Any:
        ...
    
    def current(self) -> Any:
        ...
    
    def set(self, value: Any) -> None:
        ...
    
    def reset(self) -> None:
        ...
    
    def has_changed(self) -> bool:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __deepcopy__(self, _): # -> _Option:
        ...
    


@dataclass
class _UnconvertedStrings:
    val: list[str]
    ...


class OptManager:
    """
    OptManager is the base class from which Options objects are derived.

    .changed is a Signal that triggers whenever options are
    updated. If any handler in the chain raises an exceptions.OptionsError
    exception, all changes are rolled back, the exception is suppressed,
    and the .errored signal is notified.

    Optmanager always returns a deep copy of options to ensure that
    mutation doesn't change the option state inadvertently.
    """
    def __init__(self) -> None:
        ...
    
    def add_option(self, name: str, typespec: type | object, default: Any, help: str, choices: Sequence[str] | None = ...) -> None:
        ...
    
    @contextlib.contextmanager
    def rollback(self, updated, reraise=...): # -> Generator[None, Any, None]:
        ...
    
    def subscribe(self, func, opts): # -> None:
        """
        Subscribe a callable to the .changed signal, but only for a
        specified list of options. The callable should accept arguments
        (options, updated), and may raise an OptionsError.

        The event will automatically be unsubscribed if the callable goes out of scope.
        """
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __deepcopy__(self, memodict=...): # -> OptManager:
        ...
    
    __copy__ = ...
    def __getattr__(self, attr): # -> Any:
        ...
    
    def __setattr__(self, attr, value): # -> None:
        ...
    
    def keys(self): # -> set[str]:
        ...
    
    def items(self): # -> dict_items[str, Any]:
        ...
    
    def __contains__(self, k): # -> bool:
        ...
    
    def reset(self): # -> None:
        """
        Restore defaults for all options.
        """
        ...
    
    def update_known(self, **kwargs): # -> dict[Unknown, Unknown]:
        """
        Update and set all known options from kwargs. Returns a dictionary
        of unknown options.
        """
        ...
    
    def update_defer(self, **kwargs): # -> None:
        ...
    
    def update(self, **kwargs): # -> None:
        ...
    
    def setter(self, attr): # -> (x: Unknown) -> None:
        """
        Generate a setter for a given attribute. This returns a callable
        taking a single argument.
        """
        ...
    
    def toggler(self, attr): # -> () -> None:
        """
        Generate a toggler for a boolean attribute. This returns a callable
        that takes no arguments.
        """
        ...
    
    def default(self, option: str) -> Any:
        ...
    
    def has_changed(self, option): # -> Any:
        """
        Has the option changed from the default?
        """
        ...
    
    def merge(self, opts): # -> None:
        """
        Merge a dict of options into this object. Options that have None
        value are ignored. Lists and tuples are appended to the current
        option value.
        """
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def set(self, *specs: str, defer: bool = ...) -> None:
        """
        Takes a list of set specification in standard form (option=value).
        Options that are known are updated immediately. If defer is true,
        options that are not known are deferred, and will be set once they
        are added.

        May raise an `OptionsError` if a value is malformed or an option is unknown and defer is False.
        """
        ...
    
    def process_deferred(self) -> None:
        """
        Processes options that were deferred in previous calls to set, and
        have since been added.
        """
        ...
    
    def make_parser(self, parser, optname, metavar=..., short=...): # -> None:
        """
        Auto-Create a command-line parser entry for a named option. If the
        option does not exist, it is ignored.
        """
        ...
    


def dump_defaults(opts, out: TextIO):
    """
    Dumps an annotated file with all options.
    """
    ...

def dump_dicts(opts, keys: Iterable[str] | None = ...) -> dict:
    """
    Dumps the options into a list of dict object.

    Return: A list like: { "anticache": { type: "bool", default: false, value: true, help: "help text"} }
    """
    ...

def parse(text): # -> dict[Unknown, Unknown]:
    ...

def load(opts: OptManager, text: str, cwd: Path | str | None = ...) -> None:
    """
    Load configuration from text, over-writing options already set in
    this object. May raise OptionsError if the config file is invalid.
    """
    ...

def load_paths(opts: OptManager, *paths: Path | str) -> None:
    """
    Load paths in order. Each path takes precedence over the previous
    path. Paths that don't exist are ignored, errors raise an
    OptionsError.
    """
    ...

def serialize(opts: OptManager, file: TextIO, text: str, defaults: bool = ...) -> None:
    """
    Performs a round-trip serialization. If text is not None, it is
    treated as a previous serialization that should be modified
    in-place.

    - If "defaults" is False, only options with non-default values are
        serialized. Default values in text are preserved.
    - Unknown options in text are removed.
    - Raises OptionsError if text is invalid.
    """
    ...

def save(opts: OptManager, path: Path | str, defaults: bool = ...) -> None:
    """
    Save to path. If the destination file exists, modify it in-place.

    Raises OptionsError if the existing data is corrupt.
    """
    ...

def relative_path(script_path: Path | str, *, relative_to: Path | str) -> Path:
    """
    Make relative paths found in config files relative to said config file,
    instead of relative to where the command is ran.
    """
    ...

