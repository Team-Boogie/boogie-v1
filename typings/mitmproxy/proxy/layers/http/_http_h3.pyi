"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterable
from dataclasses import dataclass
from aioquic.h3.connection import H3Connection, H3Event, Headers
from mitmproxy import connection
from mitmproxy.proxy import layer
from mitmproxy.proxy.layers.quic import QuicConnectionClosed, QuicStreamEvent

@dataclass
class TrailersReceived(H3Event):
    """
    The TrailersReceived event is fired whenever trailers are received.
    """
    trailers: Headers
    stream_id: int
    stream_ended: bool
    ...


@dataclass
class StreamClosed(H3Event):
    """
    The StreamReset event is fired when the peer is sending a CLOSE_STREAM
    or a STOP_SENDING frame. For HTTP/3, we don't differentiate between the two.
    """
    stream_id: int
    error_code: int
    ...


class MockQuic:
    """
    aioquic intermingles QUIC and HTTP/3. This is something we don't want to do because that makes testing much harder.
    Instead, we mock our QUIC connection object here and then take out the wire data to be sent.
    """
    def __init__(self, conn: connection.Connection, is_client: bool) -> None:
        ...
    
    def close(self, error_code: int = ..., frame_type: int | None = ..., reason_phrase: str = ...) -> None:
        ...
    
    def get_next_available_stream_id(self, is_unidirectional: bool = ...) -> int:
        ...
    
    def reset_stream(self, stream_id: int, error_code: int) -> None:
        ...
    
    def stop_send(self, stream_id: int, error_code: int) -> None:
        ...
    
    def send_stream_data(self, stream_id: int, data: bytes, end_stream: bool = ...) -> None:
        ...
    


class LayeredH3Connection(H3Connection):
    """
    Creates a H3 connection using a fake QUIC connection, which allows layer separation.
    Also ensures that headers, data and trailers are sent in that order.
    """
    def __init__(self, conn: connection.Connection, is_client: bool, enable_webtransport: bool = ...) -> None:
        ...
    
    def close_connection(self, error_code: int = ..., frame_type: int | None = ..., reason_phrase: str = ...) -> None:
        """Closes the underlying QUIC connection and ignores any incoming events."""
        ...
    
    def end_stream(self, stream_id: int) -> None:
        """Ends the given stream if not already done so."""
        ...
    
    def get_next_available_stream_id(self, is_unidirectional: bool = ...): # -> int:
        """Reserves and returns the next available stream ID."""
        ...
    
    def get_open_stream_ids(self) -> Iterable[int]:
        """Iterates over all non-special open streams"""
        ...
    
    def handle_connection_closed(self, event: QuicConnectionClosed) -> None:
        ...
    
    def handle_stream_event(self, event: QuicStreamEvent) -> list[H3Event]:
        ...
    
    def has_sent_headers(self, stream_id: int) -> bool:
        """Indicates whether headers have been sent over the given stream."""
        ...
    
    def close_stream(self, stream_id: int, error_code: int, stop_send: bool = ...) -> None:
        """Close a stream that hasn't been closed locally yet."""
        ...
    
    def send_data(self, stream_id: int, data: bytes, end_stream: bool = ...) -> None:
        """Sends data over the given stream."""
        ...
    
    def send_datagram(self, flow_id: int, data: bytes) -> None:
        ...
    
    def send_headers(self, stream_id: int, headers: Headers, end_stream: bool = ...) -> None:
        """Sends headers over the given stream."""
        ...
    
    def send_trailers(self, stream_id: int, trailers: Headers) -> None:
        """Sends trailers over the given stream and ends it."""
        ...
    
    def transmit(self) -> layer.CommandGenerator[None]:
        """Yields all pending commands for the upper QUIC layer."""
        ...
    


__all__ = ["LayeredH3Connection", "StreamClosed", "TrailersReceived"]
