"""
This type stub file was generated by pyright.
"""

import abc
from collections.abc import Callable
from typing import Union
from h11._readers import ChunkedReader, ContentLengthReader, Http10Reader
from h11._receivebuffer import ReceiveBuffer
from ...context import Context
from ._base import HttpConnection
from ._events import HttpEvent, RequestData, RequestEndOfMessage, RequestProtocolError, ResponseData, ResponseEndOfMessage, ResponseProtocolError
from mitmproxy import http
from mitmproxy.connection import Connection
from mitmproxy.proxy import events, layer
from mitmproxy.proxy.layers.http._base import StreamId
from mitmproxy.proxy.utils import expect

TBodyReader = Union[ChunkedReader, Http10Reader, ContentLengthReader]
class Http1Connection(HttpConnection, metaclass=abc.ABCMeta):
    stream_id: StreamId | None = ...
    request: http.Request | None = ...
    response: http.Response | None = ...
    request_done: bool = ...
    response_done: bool = ...
    state: Callable[[events.Event], layer.CommandGenerator[None]] | Callable
    body_reader: TBodyReader
    buf: ReceiveBuffer
    ReceiveProtocolError: type[RequestProtocolError | ResponseProtocolError]
    ReceiveData: type[RequestData | ResponseData]
    ReceiveEndOfMessage: type[RequestEndOfMessage | ResponseEndOfMessage]
    def __init__(self, context: Context, conn: Connection) -> None:
        ...
    
    @abc.abstractmethod
    def send(self, event: HttpEvent) -> layer.CommandGenerator[None]:
        ...
    
    @abc.abstractmethod
    def read_headers(self, event: events.ConnectionEvent) -> layer.CommandGenerator[None]:
        ...
    
    @expect(events.Start)
    def start(self, _) -> layer.CommandGenerator[None]:
        ...
    
    state = ...
    def read_body(self, event: events.Event) -> layer.CommandGenerator[None]:
        ...
    
    def wait(self, event: events.Event) -> layer.CommandGenerator[None]:
        """
        We wait for the current flow to be finished before parsing the next message,
        as we may want to upgrade to WebSocket or plain TCP before that.
        """
        ...
    
    def done(self, event: events.ConnectionEvent) -> layer.CommandGenerator[None]:
        ...
    
    def make_pipe(self) -> layer.CommandGenerator[None]:
        ...
    
    def passthrough(self, event: events.Event) -> layer.CommandGenerator[None]:
        ...
    
    def mark_done(self, *, request: bool = ..., response: bool = ...) -> layer.CommandGenerator[None]:
        ...
    


class Http1Server(Http1Connection):
    """A simple HTTP/1 server with no pipelining support."""
    ReceiveProtocolError = RequestProtocolError
    ReceiveData = RequestData
    ReceiveEndOfMessage = RequestEndOfMessage
    stream_id: int
    def __init__(self, context: Context) -> None:
        ...
    
    def send(self, event: HttpEvent) -> layer.CommandGenerator[None]:
        ...
    
    def read_headers(self, event: events.ConnectionEvent) -> layer.CommandGenerator[None]:
        ...
    
    def mark_done(self, *, request: bool = ..., response: bool = ...) -> layer.CommandGenerator[None]:
        ...
    


class Http1Client(Http1Connection):
    """A simple HTTP/1 client with no pipelining support."""
    ReceiveProtocolError = ResponseProtocolError
    ReceiveData = ResponseData
    ReceiveEndOfMessage = ResponseEndOfMessage
    def __init__(self, context: Context) -> None:
        ...
    
    def send(self, event: HttpEvent) -> layer.CommandGenerator[None]:
        ...
    
    def read_headers(self, event: events.ConnectionEvent) -> layer.CommandGenerator[None]:
        ...
    


def should_make_pipe(request: http.Request, response: http.Response) -> bool:
    ...

def make_body_reader(expected_size: int | None) -> TBodyReader:
    ...

def make_error_response(status_code: int, message: str = ...) -> bytes:
    ...

__all__ = ["Http1Client", "Http1Server"]
