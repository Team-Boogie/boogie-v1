"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterator
from dataclasses import dataclass
from mitmproxy import connection, http, websocket
from mitmproxy.proxy import commands, events, layer
from mitmproxy.proxy.commands import StartHook
from mitmproxy.proxy.context import Context
from mitmproxy.proxy.events import MessageInjected
from mitmproxy.proxy.utils import expect

@dataclass
class WebsocketStartHook(StartHook):
    """
    A WebSocket connection has commenced.
    """
    flow: http.HTTPFlow
    ...


@dataclass
class WebsocketMessageHook(StartHook):
    """
    Called when a WebSocket message is received from the client or
    server. The most recent message will be flow.messages[-1]. The
    message is user-modifiable. Currently there are two types of
    messages, corresponding to the BINARY and TEXT frame types.
    """
    flow: http.HTTPFlow
    ...


@dataclass
class WebsocketEndHook(StartHook):
    """
    A WebSocket connection has ended.
    You can check `flow.websocket.close_code` to determine why it ended.
    """
    flow: http.HTTPFlow
    ...


class WebSocketMessageInjected(MessageInjected[websocket.WebSocketMessage]):
    """
    The user has injected a custom WebSocket message.
    """
    ...


class WebsocketConnection(wsproto.Connection):
    """
    A very thin wrapper around wsproto.Connection:

     - we keep the underlying connection as an attribute for easy access.
     - we add a framebuffer for incomplete messages
     - we wrap .send() so that we can directly yield it.
    """
    conn: connection.Connection
    frame_buf: list[bytes]
    def __init__(self, *args, conn: connection.Connection, **kwargs) -> None:
        ...
    
    def send2(self, event: wsproto.events.Event) -> commands.SendData:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class WebsocketLayer(layer.Layer):
    """
    WebSocket layer that intercepts and relays messages.
    """
    flow: http.HTTPFlow
    client_ws: WebsocketConnection
    server_ws: WebsocketConnection
    def __init__(self, context: Context, flow: http.HTTPFlow) -> None:
        ...
    
    @expect(events.Start)
    def start(self, _) -> layer.CommandGenerator[None]:
        ...
    
    _handle_event = ...
    @expect(events.DataReceived, events.ConnectionClosed, WebSocketMessageInjected)
    def relay_messages(self, event: events.Event) -> layer.CommandGenerator[None]:
        ...
    
    @expect(events.DataReceived, events.ConnectionClosed, WebSocketMessageInjected)
    def done(self, _) -> layer.CommandGenerator[None]:
        ...
    


class Fragmentizer:
    """
    Theory (RFC 6455):
       Unless specified otherwise by an extension, frames have no semantic
       meaning.  An intermediary might coalesce and/or split frames, [...]

    Practice:
        Some WebSocket servers reject large payload sizes.
        Other WebSocket servers reject CONTINUATION frames.

    As a workaround, we either retain the original chunking or, if the payload has been modified, use ~4kB chunks.
    If one deals with web servers that do not support CONTINUATION frames, addons need to monkeypatch FRAGMENT_SIZE
    if they need to modify the message.
    """
    FRAGMENT_SIZE = ...
    def __init__(self, fragments: list[bytes], is_text: bool) -> None:
        ...
    
    def msg(self, data: bytes, message_finished: bool): # -> TextMessage | BytesMessage:
        ...
    
    def __call__(self, content: bytes) -> Iterator[wsproto.events.Message]:
        ...
    


