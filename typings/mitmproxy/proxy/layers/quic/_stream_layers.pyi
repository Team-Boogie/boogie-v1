"""
This type stub file was generated by pyright.
"""

from collections.abc import Callable
from aioquic.quic.configuration import QuicConfiguration
from aioquic.quic.connection import QuicConnection
from ._hooks import QuicTlsSettings
from mitmproxy import connection
from mitmproxy.net import tls
from mitmproxy.proxy import commands, context, events, layer, tunnel

"""
This module contains the client and server proxy layers for QUIC streams
which decrypt and encrypt traffic. Decrypted stream data is then forwarded
to either the raw layers, or the HTTP/3 client in ../http/_http3.py.
"""
SUPPORTED_QUIC_VERSIONS_SERVER = ...
class QuicLayer(tunnel.TunnelLayer):
    quic: QuicConnection | None = ...
    tls: QuicTlsSettings | None = ...
    def __init__(self, context: context.Context, conn: connection.Connection, time: Callable[[], float] | None) -> None:
        ...
    
    def event_to_child(self, event: events.Event) -> layer.CommandGenerator[None]:
        ...
    
    def start_tls(self, original_destination_connection_id: bytes | None) -> layer.CommandGenerator[None]:
        """Initiates the aioquic connection."""
        ...
    
    def tls_interact(self) -> layer.CommandGenerator[None]:
        """Retrieves all pending outgoing packets from aioquic and sends the data."""
        ...
    
    def receive_handshake_data(self, data: bytes) -> layer.CommandGenerator[tuple[bool, str | None]]:
        ...
    
    def on_handshake_error(self, err: str) -> layer.CommandGenerator[None]:
        ...
    
    def receive_data(self, data: bytes) -> layer.CommandGenerator[None]:
        ...
    
    def receive_close(self) -> layer.CommandGenerator[None]:
        ...
    
    def send_data(self, data: bytes) -> layer.CommandGenerator[None]:
        ...
    
    def send_close(self, command: commands.CloseConnection) -> layer.CommandGenerator[None]:
        ...
    


class ServerQuicLayer(QuicLayer):
    """
    This layer establishes QUIC for a single server connection.
    """
    wait_for_clienthello: bool = ...
    def __init__(self, context: context.Context, conn: connection.Server | None = ..., time: Callable[[], float] | None = ...) -> None:
        ...
    
    def start_handshake(self) -> layer.CommandGenerator[None]:
        ...
    
    def event_to_child(self, event: events.Event) -> layer.CommandGenerator[None]:
        ...
    
    def on_handshake_error(self, err: str) -> layer.CommandGenerator[None]:
        ...
    


class ClientQuicLayer(QuicLayer):
    """
    This layer establishes QUIC on a single client connection.
    """
    server_tls_available: bool
    handshake_datagram_buf: list[bytes]
    def __init__(self, context: context.Context, time: Callable[[], float] | None = ...) -> None:
        ...
    
    def start_handshake(self) -> layer.CommandGenerator[None]:
        ...
    
    def receive_handshake_data(self, data: bytes) -> layer.CommandGenerator[tuple[bool, str | None]]:
        ...
    
    def start_server_tls(self) -> layer.CommandGenerator[str | None]:
        ...
    
    def on_handshake_error(self, err: str) -> layer.CommandGenerator[None]:
        ...
    
    def errored(self, event: events.Event) -> layer.CommandGenerator[None]:
        ...
    


class QuicSecretsLogger:
    logger: tls.MasterSecretLogger
    def __init__(self, logger: tls.MasterSecretLogger) -> None:
        ...
    
    def write(self, s: str) -> int:
        ...
    
    def flush(self) -> None:
        ...
    


def error_code_to_str(error_code: int) -> str:
    """Returns the corresponding name of the given error code or a string containing its numeric value."""
    ...

def is_success_error_code(error_code: int) -> bool:
    """Returns whether the given error code actually indicates no error."""
    ...

def tls_settings_to_configuration(settings: QuicTlsSettings, is_client: bool, server_name: str | None = ...) -> QuicConfiguration:
    """Converts `QuicTlsSettings` to `QuicConfiguration`."""
    ...

