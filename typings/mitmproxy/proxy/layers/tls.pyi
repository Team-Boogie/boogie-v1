"""
This type stub file was generated by pyright.
"""

from collections.abc import Iterator
from dataclasses import dataclass
from OpenSSL import SSL
from mitmproxy import connection
from mitmproxy.proxy import commands, context, events, layer, tunnel
from mitmproxy.proxy.commands import StartHook
from mitmproxy.tls import ClientHello, ClientHelloData, TlsData

def handshake_record_contents(data: bytes) -> Iterator[bytes]:
    """
    Returns a generator that yields the bytes contained in each handshake record.
    This will raise an error on the first non-handshake record, so fully exhausting this
    generator is a bad idea.
    """
    ...

def get_client_hello(data: bytes) -> bytes | None:
    """
    Read all TLS records that contain the initial ClientHello.
    Returns the raw handshake packet bytes, without TLS record headers.
    """
    ...

def parse_client_hello(data: bytes) -> ClientHello | None:
    """
    Check if the supplied bytes contain a full ClientHello message,
    and if so, parse it.

    Returns:
        - A ClientHello object on success
        - None, if the TLS record is not complete

    Raises:
        - A ValueError, if the passed ClientHello is invalid
    """
    ...

def dtls_handshake_record_contents(data: bytes) -> Iterator[bytes]:
    """
    Returns a generator that yields the bytes contained in each handshake record.
    This will raise an error on the first non-handshake record, so fully exhausting this
    generator is a bad idea.
    """
    ...

def get_dtls_client_hello(data: bytes) -> bytes | None:
    """
    Read all DTLS records that contain the initial ClientHello.
    Returns the raw handshake packet bytes, without TLS record headers.
    """
    ...

def dtls_parse_client_hello(data: bytes) -> ClientHello | None:
    """
    Check if the supplied bytes contain a full ClientHello message,
    and if so, parse it.

    Returns:
        - A ClientHello object on success
        - None, if the TLS record is not complete

    Raises:
        - A ValueError, if the passed ClientHello is invalid
    """
    ...

HTTP1_ALPNS = ...
HTTP2_ALPN = ...
HTTP3_ALPN = ...
HTTP_ALPNS = ...
@dataclass
class TlsClienthelloHook(StartHook):
    """
    Mitmproxy has received a TLS ClientHello message.

    This hook decides whether a server connection is needed
    to negotiate TLS with the client (data.establish_server_tls_first)
    """
    data: ClientHelloData
    ...


@dataclass
class TlsStartClientHook(StartHook):
    """
    TLS negotation between mitmproxy and a client is about to start.

    An addon is expected to initialize data.ssl_conn.
    (by default, this is done by `mitmproxy.addons.tlsconfig`)
    """
    data: TlsData
    ...


@dataclass
class TlsStartServerHook(StartHook):
    """
    TLS negotation between mitmproxy and a server is about to start.

    An addon is expected to initialize data.ssl_conn.
    (by default, this is done by `mitmproxy.addons.tlsconfig`)
    """
    data: TlsData
    ...


@dataclass
class TlsEstablishedClientHook(StartHook):
    """
    The TLS handshake with the client has been completed successfully.
    """
    data: TlsData
    ...


@dataclass
class TlsEstablishedServerHook(StartHook):
    """
    The TLS handshake with the server has been completed successfully.
    """
    data: TlsData
    ...


@dataclass
class TlsFailedClientHook(StartHook):
    """
    The TLS handshake with the client has failed.
    """
    data: TlsData
    ...


@dataclass
class TlsFailedServerHook(StartHook):
    """
    The TLS handshake with the server has failed.
    """
    data: TlsData
    ...


class TLSLayer(tunnel.TunnelLayer):
    tls: SSL.Connection = ...
    def __init__(self, context: context.Context, conn: connection.Connection) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def is_dtls(self): # -> bool:
        ...
    
    @property
    def proto_name(self): # -> Literal['DTLS', 'TLS']:
        ...
    
    def start_tls(self) -> layer.CommandGenerator[None]:
        ...
    
    def tls_interact(self) -> layer.CommandGenerator[None]:
        ...
    
    def receive_handshake_data(self, data: bytes) -> layer.CommandGenerator[tuple[bool, str | None]]:
        ...
    
    def on_handshake_error(self, err: str) -> layer.CommandGenerator[None]:
        ...
    
    def receive_data(self, data: bytes) -> layer.CommandGenerator[None]:
        ...
    
    def receive_close(self) -> layer.CommandGenerator[None]:
        ...
    
    def send_data(self, data: bytes) -> layer.CommandGenerator[None]:
        ...
    
    def send_close(self, command: commands.CloseConnection) -> layer.CommandGenerator[None]:
        ...
    


class ServerTLSLayer(TLSLayer):
    """
    This layer establishes TLS for a single server connection.
    """
    wait_for_clienthello: bool = ...
    def __init__(self, context: context.Context, conn: connection.Server | None = ...) -> None:
        ...
    
    def start_handshake(self) -> layer.CommandGenerator[None]:
        ...
    
    def event_to_child(self, event: events.Event) -> layer.CommandGenerator[None]:
        ...
    
    def on_handshake_error(self, err: str) -> layer.CommandGenerator[None]:
        ...
    


class ClientTLSLayer(TLSLayer):
    """
    This layer establishes TLS on a single client connection.

    ┌─────┐
    │Start│
    └┬────┘
     ↓
    ┌────────────────────┐
    │Wait for ClientHello│
    └┬───────────────────┘
     ↓
    ┌────────────────┐
    │Process messages│
    └────────────────┘

    """
    recv_buffer: bytearray
    server_tls_available: bool
    client_hello_parsed: bool = ...
    def __init__(self, context: context.Context) -> None:
        ...
    
    def start_handshake(self) -> layer.CommandGenerator[None]:
        ...
    
    def receive_handshake_data(self, data: bytes) -> layer.CommandGenerator[tuple[bool, str | None]]:
        ...
    
    def start_server_tls(self) -> layer.CommandGenerator[str | None]:
        """
        We often need information from the upstream connection to establish TLS with the client.
        For example, we need to check if the client does ALPN or not.
        """
        ...
    
    def on_handshake_error(self, err: str) -> layer.CommandGenerator[None]:
        ...
    
    def errored(self, event: events.Event) -> layer.CommandGenerator[None]:
        ...
    


class MockTLSLayer(TLSLayer):
    """Mock layer to disable actual TLS and use cleartext in tests.

    Use like so:
        monkeypatch.setattr(tls, "ServerTLSLayer", tls.MockTLSLayer)
    """
    def __init__(self, ctx: context.Context) -> None:
        ...
    


