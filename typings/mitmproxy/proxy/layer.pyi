"""
This type stub file was generated by pyright.
"""

import collections
from collections.abc import Generator
from dataclasses import dataclass
from typing import Any, ClassVar, NamedTuple, TypeVar
from mitmproxy.proxy import commands, events
from mitmproxy.proxy.commands import Command, StartHook
from mitmproxy.proxy.context import Context

"""
Base class for protocol layers.
"""
T = TypeVar("T")
CommandGenerator = Generator[Command, Any, T]
MAX_LOG_STATEMENT_SIZE = ...
class Paused(NamedTuple):
    """
    State of a layer that's paused because it is waiting for a command reply.
    """
    command: commands.Command
    generator: CommandGenerator
    ...


class Layer:
    """
    The base class for all protocol layers.

    Layers interface with their child layer(s) by calling .handle_event(event),
    which returns a list (more precisely: a generator) of commands.
    Most layers do not implement .directly, but instead implement ._handle_event, which
    is called by the default implementation of .handle_event.
    The default implementation of .handle_event allows layers to emulate blocking code:
    When ._handle_event yields a command that has its blocking attribute set to True, .handle_event pauses
    the execution of ._handle_event and waits until it is called with the corresponding CommandCompleted event.
    All events encountered in the meantime are buffered and replayed after execution is resumed.

    The result is code that looks like blocking code, but is not blocking:

        def _handle_event(self, event):
            err = yield OpenConnection(server)  # execution continues here after a connection has been established.

    Technically this is very similar to how coroutines are implemented.
    """
    __last_debug_message: ClassVar[str] = ...
    context: Context
    _paused: Paused | None
    _paused_event_queue: collections.deque[events.Event]
    debug: str | None = ...
    def __init__(self, context: Context) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @property
    def stack_pos(self) -> str:
        """repr() for this layer and all its parent layers, only useful for debugging."""
        ...
    
    def handle_event(self, event: events.Event) -> CommandGenerator[None]:
        ...
    


mevents = events
class NextLayer(Layer):
    layer: Layer | None
    events: list[mevents.Event]
    _ask_on_start: bool
    def __init__(self, context: Context, ask_on_start: bool = ...) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def handle_event(self, event: mevents.Event): # -> Generator[Command, Unknown, None]:
        ...
    
    def data_client(self): # -> bytes:
        ...
    
    def data_server(self): # -> bytes:
        ...
    


@dataclass
class NextLayerHook(StartHook):
    """
    Network layers are being switched. You may change which layer will be used by setting data.layer.

    (by default, this is done by mitmproxy.addons.NextLayer)
    """
    data: NextLayer
    ...


