"""
This type stub file was generated by pyright.
"""

import sys
from abc import ABCMeta, abstractmethod
from dataclasses import dataclass
from functools import cache
from typing import ClassVar, Literal, Self
from mitmproxy.coretypes.serializable import Serializable

"""
This module is responsible for parsing proxy mode specifications such as
`"regular"`, `"reverse:https://example.com"`, or `"socks5@1234"`. The general syntax is

    mode [: mode_configuration] [@ [listen_addr:]listen_port]

For a full example, consider `reverse:https://example.com@127.0.0.1:443`.
This would spawn a reverse proxy on port 443 bound to localhost.
The mode is `reverse`, and the mode data is `https://example.com`.
Examples:

    mode = ProxyMode.parse("regular@1234")
    assert mode.listen_port == 1234
    assert isinstance(mode, RegularMode)

    ProxyMode.parse("reverse:example.com@invalid-port")  # ValueError

    RegularMode.parse("regular")  # ok
    RegularMode.parse("socks5")  # ValueError

"""
if sys.version_info < (3, 11):
    ...
else:
    ...
@dataclass(frozen=True)
class ProxyMode(Serializable, metaclass=ABCMeta):
    """
    Parsed representation of a proxy mode spec. Subclassed for each specific mode,
    which then does its own data validation.
    """
    full_spec: str
    data: str
    custom_listen_host: str | None
    custom_listen_port: int | None
    type_name: ClassVar[str]
    __types: ClassVar[dict[str, type[ProxyMode]]] = ...
    def __init_subclass__(cls, **kwargs): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    @abstractmethod
    def __post_init__(self) -> None:
        """Validation of data happens here."""
        ...
    
    @property
    @abstractmethod
    def description(self) -> str:
        """The mode description that will be used in server logs and UI."""
        ...
    
    @property
    def default_port(self) -> int | None:
        """
        Default listen port of servers for this mode, see `ProxyMode.listen_port()`.
        """
        ...
    
    @property
    @abstractmethod
    def transport_protocol(self) -> Literal["tcp", "udp", "both"]:
        """The transport protocol used by this mode's server."""
        ...
    
    @classmethod
    @cache
    def parse(cls, spec: str) -> Self:
        """
        Parse a proxy mode specification and return the corresponding `ProxyMode` instance.
        """
        ...
    
    def listen_host(self, default: str | None = ...) -> str:
        """
        Return the address a server for this mode should listen on. This can be either directly
        specified in the spec or taken from a user-configured global default (`options.listen_host`).
        By default, return an empty string to listen on all hosts.
        """
        ...
    
    def listen_port(self, default: int | None = ...) -> int | None:
        """
        Return the port a server for this mode should listen on. This can be either directly
        specified in the spec, taken from a user-configured global default (`options.listen_port`),
        or from `ProxyMode.default_port`.
        May be `None` for modes that don't bind to a specific address, e.g. local redirect mode.
        """
        ...
    
    @classmethod
    def from_state(cls, state): # -> ProxyMode:
        ...
    
    def get_state(self): # -> str:
        ...
    
    def set_state(self, state): # -> None:
        ...
    


TCP: Literal["tcp", "udp", "both"] = ...
UDP: Literal["tcp", "udp", "both"] = ...
BOTH: Literal["tcp", "udp", "both"] = ...
class RegularMode(ProxyMode):
    """A regular HTTP(S) proxy that is interfaced with `HTTP CONNECT` calls (or absolute-form HTTP requests)."""
    description = ...
    transport_protocol = ...
    def __post_init__(self) -> None:
        ...
    


class TransparentMode(ProxyMode):
    """A transparent proxy, see https://docs.mitmproxy.org/dev/howto-transparent/"""
    description = ...
    transport_protocol = ...
    def __post_init__(self) -> None:
        ...
    


class UpstreamMode(ProxyMode):
    """A regular HTTP(S) proxy, but all connections are forwarded to a second upstream HTTP(S) proxy."""
    description = ...
    transport_protocol = ...
    scheme: Literal["http", "https"]
    address: tuple[str, int]
    def __post_init__(self) -> None:
        ...
    


class ReverseMode(ProxyMode):
    """A reverse proxy. This acts like a normal server, but redirects all requests to a fixed target."""
    description = ...
    transport_protocol = ...
    scheme: Literal["http", "https", "http3", "tls", "dtls", "tcp", "udp", "dns", "quic"]
    address: tuple[str, int]
    def __post_init__(self) -> None:
        ...
    
    @property
    def default_port(self) -> int | None:
        ...
    


class Socks5Mode(ProxyMode):
    """A SOCKSv5 proxy."""
    description = ...
    default_port = ...
    transport_protocol = ...
    def __post_init__(self) -> None:
        ...
    


class DnsMode(ProxyMode):
    """A DNS server."""
    description = ...
    default_port = ...
    transport_protocol = ...
    def __post_init__(self) -> None:
        ...
    


class WireGuardMode(ProxyMode):
    """Proxy Server based on WireGuard"""
    description = ...
    default_port = ...
    transport_protocol = ...
    def __post_init__(self) -> None:
        ...
    


class LocalMode(ProxyMode):
    """OS-level transparent proxy."""
    description = ...
    transport_protocol = ...
    default_port = ...
    def __post_init__(self) -> None:
        ...
    


class TunMode(ProxyMode):
    """A Tun interface."""
    description = ...
    default_port = ...
    transport_protocol = ...
    def __post_init__(self) -> None:
        ...
    


class OsProxyMode(ProxyMode):
    """Deprecated alias for LocalMode"""
    description = ...
    transport_protocol = ...
    default_port = ...
    def __post_init__(self) -> None:
        ...
    


