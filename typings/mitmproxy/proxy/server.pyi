"""
This type stub file was generated by pyright.
"""

import abc
import asyncio
import collections
import mitmproxy_rs
from collections.abc import Awaitable, Callable, MutableMapping
from contextlib import contextmanager
from dataclasses import dataclass
from types import TracebackType
from typing import Literal
from mitmproxy import options as moptions
from mitmproxy.connection import Address, Client, Connection
from mitmproxy.proxy import commands, events, layer, mode_specs
from mitmproxy.proxy.context import Context

"""
Proxy Server Implementation using asyncio.
The very high level overview is as follows:

    - Spawn one coroutine per client connection and create a reverse proxy layer to example.com
    - Process any commands from layer (such as opening a server connection)
    - Wait for any IO and send it as events to top layer.
"""
logger = ...
TCP_TIMEOUT = ...
UDP_TIMEOUT = ...
class TimeoutWatchdog:
    last_activity: float
    timeout: int
    can_timeout: asyncio.Event
    blocker: int
    def __init__(self, timeout: int, callback: Callable[[], Awaitable]) -> None:
        ...
    
    def register_activity(self): # -> None:
        ...
    
    async def watch(self): # -> None:
        ...
    
    @contextmanager
    def disarm(self): # -> Generator[None, Any, None]:
        ...
    


@dataclass
class ConnectionIO:
    handler: asyncio.Task | None = ...
    reader: asyncio.StreamReader | mitmproxy_rs.Stream | None = ...
    writer: asyncio.StreamWriter | mitmproxy_rs.Stream | None = ...


class ConnectionHandler(metaclass=abc.ABCMeta):
    transports: MutableMapping[Connection, ConnectionIO]
    timeout_watchdog: TimeoutWatchdog
    client: Client
    max_conns: collections.defaultdict[Address, asyncio.Semaphore]
    layer: layer.Layer
    wakeup_timer: set[asyncio.Task]
    hook_tasks: set[asyncio.Task]
    def __init__(self, context: Context) -> None:
        ...
    
    async def handle_client(self) -> None:
        ...
    
    async def open_connection(self, command: commands.OpenConnection) -> None:
        ...
    
    async def wakeup(self, request: commands.RequestWakeup) -> None:
        ...
    
    async def handle_connection(self, connection: Connection) -> None:
        """
        Handle a connection for its entire lifetime.
        This means we read until EOF,
        but then possibly also keep on waiting for our side of the connection to be closed.
        """
        ...
    
    async def drain_writers(self): # -> None:
        """
        Drain all writers to create some backpressure. We won't continue reading until there's space available in our
        write buffers, so if we cannot write fast enough our own read buffers run full and the TCP recv stream is throttled.
        """
        ...
    
    async def on_timeout(self) -> None:
        ...
    
    async def hook_task(self, hook: commands.StartHook) -> None:
        ...
    
    @abc.abstractmethod
    async def handle_hook(self, hook: commands.StartHook) -> None:
        ...
    
    def log(self, message: str, level: int = ..., exc_info: Literal[True] | tuple[type[BaseException], BaseException, TracebackType | None] | None = ...) -> None:
        ...
    
    async def server_event(self, event: events.Event) -> None:
        ...
    
    def close_connection(self, connection: Connection, half_close: bool = ...) -> None:
        ...
    


class LiveConnectionHandler(ConnectionHandler, metaclass=abc.ABCMeta):
    def __init__(self, reader: asyncio.StreamReader | mitmproxy_rs.Stream, writer: asyncio.StreamWriter | mitmproxy_rs.Stream, options: moptions.Options, mode: mode_specs.ProxyMode) -> None:
        ...
    


class SimpleConnectionHandler(LiveConnectionHandler):
    """Simple handler that does not really process any hooks."""
    hook_handlers: dict[str, Callable]
    def __init__(self, reader, writer, options, mode, hook_handlers) -> None:
        ...
    
    async def handle_hook(self, hook: commands.StartHook) -> None:
        ...
    


if __name__ == "__main__":
    loop = ...
    opts = ...
    async def handle(reader, writer): # -> None:
        ...
    
    coro = ...
    server = ...
