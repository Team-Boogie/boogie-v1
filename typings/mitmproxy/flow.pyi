"""
This type stub file was generated by pyright.
"""

from dataclasses import dataclass
from typing import ClassVar
from mitmproxy import connection
from mitmproxy.coretypes import serializable

@dataclass
class Error(serializable.SerializableDataclass):
    """
    An Error.

    This is distinct from an protocol error response (say, a HTTP code 500),
    which is represented by a normal `mitmproxy.http.Response` object. This class is
    responsible for indicating errors that fall outside of normal protocol
    communications, like interrupted connections, timeouts, or protocol errors.
    """
    msg: str
    timestamp: float = ...
    KILLED_MESSAGE: ClassVar[str] = ...
    def __str__(self) -> str:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class Flow(serializable.Serializable):
    """
    Base class for network flows. A flow is a collection of objects,
    for example HTTP request/response pairs or a list of TCP messages.

    See also:
     - mitmproxy.http.HTTPFlow
     - mitmproxy.tcp.TCPFlow
     - mitmproxy.udp.UDPFlow
    """
    client_conn: connection.Client
    server_conn: connection.Server
    error: Error | None = ...
    intercepted: bool
    marked: str = ...
    is_replay: str | None
    live: bool
    timestamp_created: float
    def __init__(self, client_conn: connection.Client, server_conn: connection.Server, live: bool = ...) -> None:
        ...
    
    __types: dict[str, type[Flow]] = ...
    type: ClassVar[str]
    def __init_subclass__(cls, **kwargs): # -> None:
        ...
    
    def get_state(self) -> serializable.State:
        ...
    
    def set_state(self, state: serializable.State) -> None:
        ...
    
    @classmethod
    def from_state(cls, state: serializable.State) -> Flow:
        ...
    
    def copy(self): # -> Self@Flow:
        """Make a copy of this flow."""
        ...
    
    def modified(self): # -> Any | Literal[False]:
        """
        `True` if this file has been modified by a user, `False` otherwise.
        """
        ...
    
    def backup(self, force=...): # -> None:
        """
        Save a backup of this flow, which can be restored by calling `Flow.revert()`.
        """
        ...
    
    def revert(self): # -> None:
        """
        Revert to the last backed up state.
        """
        ...
    
    @property
    def killable(self): # -> bool:
        """*Read-only:* `True` if this flow can be killed, `False` otherwise."""
        ...
    
    def kill(self): # -> None:
        """
        Kill this flow. The current request/response will not be forwarded to its destination.
        """
        ...
    
    def intercept(self): # -> None:
        """
        Intercept this Flow. Processing will stop until resume is
        called.
        """
        ...
    
    async def wait_for_resume(self): # -> None:
        """
        Wait until this Flow is resumed.
        """
        ...
    
    def resume(self): # -> None:
        """
        Continue with the flow â€“ called after an intercept().
        """
        ...
    
    @property
    def timestamp_start(self) -> float:
        """
        *Read-only:* Start time of the flow.
        Depending on the flow type, this property is an alias for
        `mitmproxy.connection.Client.timestamp_start` or `mitmproxy.http.Request.timestamp_start`.
        """
        ...
    


__all__ = ["Flow", "Error"]
